/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Mon Jan 12 19:32:11 GMT 2026
 */

package com.facebook.presto.sql;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import com.facebook.presto.common.type.VarcharEnumType;
import com.facebook.presto.sql.SqlFormatter;
import com.facebook.presto.sql.tree.AddColumn;
import com.facebook.presto.sql.tree.AddConstraint;
import com.facebook.presto.sql.tree.AliasedRelation;
import com.facebook.presto.sql.tree.AllColumns;
import com.facebook.presto.sql.tree.AlterColumnNotNull;
import com.facebook.presto.sql.tree.AlterFunction;
import com.facebook.presto.sql.tree.AlterRoutineCharacteristics;
import com.facebook.presto.sql.tree.Analyze;
import com.facebook.presto.sql.tree.ArithmeticUnaryExpression;
import com.facebook.presto.sql.tree.AstVisitor;
import com.facebook.presto.sql.tree.BetweenPredicate;
import com.facebook.presto.sql.tree.BooleanLiteral;
import com.facebook.presto.sql.tree.Call;
import com.facebook.presto.sql.tree.CallArgument;
import com.facebook.presto.sql.tree.Cast;
import com.facebook.presto.sql.tree.CoalesceExpression;
import com.facebook.presto.sql.tree.ColumnDefinition;
import com.facebook.presto.sql.tree.Commit;
import com.facebook.presto.sql.tree.ConstraintSpecification;
import com.facebook.presto.sql.tree.CreateFunction;
import com.facebook.presto.sql.tree.CreateRole;
import com.facebook.presto.sql.tree.CreateSchema;
import com.facebook.presto.sql.tree.CreateTable;
import com.facebook.presto.sql.tree.CreateType;
import com.facebook.presto.sql.tree.CurrentTime;
import com.facebook.presto.sql.tree.CurrentUser;
import com.facebook.presto.sql.tree.Deallocate;
import com.facebook.presto.sql.tree.DecimalLiteral;
import com.facebook.presto.sql.tree.Delete;
import com.facebook.presto.sql.tree.DereferenceExpression;
import com.facebook.presto.sql.tree.DescribeInput;
import com.facebook.presto.sql.tree.DescribeOutput;
import com.facebook.presto.sql.tree.Descriptor;
import com.facebook.presto.sql.tree.DescriptorField;
import com.facebook.presto.sql.tree.DropBranch;
import com.facebook.presto.sql.tree.DropColumn;
import com.facebook.presto.sql.tree.DropConstraint;
import com.facebook.presto.sql.tree.DropFunction;
import com.facebook.presto.sql.tree.DropMaterializedView;
import com.facebook.presto.sql.tree.DropRole;
import com.facebook.presto.sql.tree.DropSchema;
import com.facebook.presto.sql.tree.DropTable;
import com.facebook.presto.sql.tree.DropTag;
import com.facebook.presto.sql.tree.DropView;
import com.facebook.presto.sql.tree.EnumLiteral;
import com.facebook.presto.sql.tree.Except;
import com.facebook.presto.sql.tree.Execute;
import com.facebook.presto.sql.tree.Explain;
import com.facebook.presto.sql.tree.ExplainFormat;
import com.facebook.presto.sql.tree.ExplainOption;
import com.facebook.presto.sql.tree.ExplainType;
import com.facebook.presto.sql.tree.Expression;
import com.facebook.presto.sql.tree.ExternalBodyReference;
import com.facebook.presto.sql.tree.FunctionCall;
import com.facebook.presto.sql.tree.Grant;
import com.facebook.presto.sql.tree.GrantRoles;
import com.facebook.presto.sql.tree.GrantorSpecification;
import com.facebook.presto.sql.tree.Identifier;
import com.facebook.presto.sql.tree.IfExpression;
import com.facebook.presto.sql.tree.InPredicate;
import com.facebook.presto.sql.tree.Intersect;
import com.facebook.presto.sql.tree.IntervalLiteral;
import com.facebook.presto.sql.tree.Isolation;
import com.facebook.presto.sql.tree.Join;
import com.facebook.presto.sql.tree.JoinCriteria;
import com.facebook.presto.sql.tree.LambdaArgumentDeclaration;
import com.facebook.presto.sql.tree.Lateral;
import com.facebook.presto.sql.tree.LikePredicate;
import com.facebook.presto.sql.tree.MergeInsert;
import com.facebook.presto.sql.tree.MergeUpdate;
import com.facebook.presto.sql.tree.Node;
import com.facebook.presto.sql.tree.NodeLocation;
import com.facebook.presto.sql.tree.NullIfExpression;
import com.facebook.presto.sql.tree.NullLiteral;
import com.facebook.presto.sql.tree.Offset;
import com.facebook.presto.sql.tree.OrderBy;
import com.facebook.presto.sql.tree.Prepare;
import com.facebook.presto.sql.tree.PrincipalSpecification;
import com.facebook.presto.sql.tree.Property;
import com.facebook.presto.sql.tree.QualifiedName;
import com.facebook.presto.sql.tree.Query;
import com.facebook.presto.sql.tree.RefreshMaterializedView;
import com.facebook.presto.sql.tree.Relation;
import com.facebook.presto.sql.tree.RenameColumn;
import com.facebook.presto.sql.tree.RenameSchema;
import com.facebook.presto.sql.tree.RenameTable;
import com.facebook.presto.sql.tree.RenameView;
import com.facebook.presto.sql.tree.ResetSession;
import com.facebook.presto.sql.tree.Return;
import com.facebook.presto.sql.tree.Revoke;
import com.facebook.presto.sql.tree.RevokeRoles;
import com.facebook.presto.sql.tree.Rollback;
import com.facebook.presto.sql.tree.Rollup;
import com.facebook.presto.sql.tree.RoutineCharacteristics;
import com.facebook.presto.sql.tree.Row;
import com.facebook.presto.sql.tree.SampledRelation;
import com.facebook.presto.sql.tree.SearchedCaseExpression;
import com.facebook.presto.sql.tree.Select;
import com.facebook.presto.sql.tree.SelectItem;
import com.facebook.presto.sql.tree.SetProperties;
import com.facebook.presto.sql.tree.SetRole;
import com.facebook.presto.sql.tree.SetSession;
import com.facebook.presto.sql.tree.ShowCatalogs;
import com.facebook.presto.sql.tree.ShowColumns;
import com.facebook.presto.sql.tree.ShowCreate;
import com.facebook.presto.sql.tree.ShowCreateFunction;
import com.facebook.presto.sql.tree.ShowFunctions;
import com.facebook.presto.sql.tree.ShowGrants;
import com.facebook.presto.sql.tree.ShowRoleGrants;
import com.facebook.presto.sql.tree.ShowRoles;
import com.facebook.presto.sql.tree.ShowSchemas;
import com.facebook.presto.sql.tree.ShowSession;
import com.facebook.presto.sql.tree.ShowStats;
import com.facebook.presto.sql.tree.ShowTables;
import com.facebook.presto.sql.tree.SingleColumn;
import com.facebook.presto.sql.tree.SortItem;
import com.facebook.presto.sql.tree.SqlParameterDeclaration;
import com.facebook.presto.sql.tree.StartTransaction;
import com.facebook.presto.sql.tree.SubscriptExpression;
import com.facebook.presto.sql.tree.SymbolReference;
import com.facebook.presto.sql.tree.Table;
import com.facebook.presto.sql.tree.TableElement;
import com.facebook.presto.sql.tree.TableFunctionArgument;
import com.facebook.presto.sql.tree.TableFunctionDescriptorArgument;
import com.facebook.presto.sql.tree.TableFunctionInvocation;
import com.facebook.presto.sql.tree.TableSubquery;
import com.facebook.presto.sql.tree.TableVersionExpression;
import com.facebook.presto.sql.tree.TimeLiteral;
import com.facebook.presto.sql.tree.TimestampLiteral;
import com.facebook.presto.sql.tree.TransactionAccessMode;
import com.facebook.presto.sql.tree.TransactionMode;
import com.facebook.presto.sql.tree.TruncateTable;
import com.facebook.presto.sql.tree.Union;
import com.facebook.presto.sql.tree.Unnest;
import com.facebook.presto.sql.tree.Update;
import com.facebook.presto.sql.tree.UpdateAssignment;
import com.facebook.presto.sql.tree.Use;
import com.facebook.presto.sql.tree.Values;
import com.facebook.presto.sql.tree.WhenClause;
import com.google.common.base.Converter;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.UnmodifiableIterator;
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnel;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.PriorityQueue;
import java.util.ServiceLoader;
import java.util.Set;
import java.util.SortedSet;
import java.util.Stack;
import java.util.TreeSet;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;
import org.antlr.v4.runtime.atn.Transition;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.Random;
import org.evosuite.runtime.System;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.lang.MockThrowable;
import org.junit.runner.RunWith;

public class SqlFormatter_ESTest extends SqlFormatter_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull0()  throws Throwable  {
      Random.setNextRandom((-14));
      System.setCurrentTimeMillis((-14));
      Random.setNextRandom(5053);
      NodeLocation nodeLocation0 = new NodeLocation((-14), 5053);
      Identifier identifier0 = new Identifier(nodeLocation0, ">", true);
      Identifier identifier1 = new Identifier("");
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier1, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0);
      Optional<String> optional0 = Optional.of("");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("86^<Zm");
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Class<UpdateAssignment> class0 = UpdateAssignment.class;
      ServiceLoader<UpdateAssignment> serviceLoader0 = ServiceLoader.loadInstalled(class0);
      Iterator<UpdateAssignment> iterator0 = serviceLoader0.iterator();
      ImmutableList<UpdateAssignment> immutableList1 = ImmutableList.copyOf(iterator0);
      Optional<Expression> optional1 = Optional.empty();
      Update update0 = new Update(nodeLocation0, table0, immutableList1, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(update0, optional2);
      assertEquals("UPDATE >.>.>.>.>.>.>.>..>.> SET", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull0()  throws Throwable  {
      Random.setNextRandom((-14));
      System.setCurrentTimeMillis((-14));
      Random.setNextRandom(5053);
      NodeLocation nodeLocation0 = new NodeLocation((-14), 5053);
      Identifier identifier0 = new Identifier(nodeLocation0, ">", true);
      Identifier identifier1 = new Identifier("");
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier1, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      QualifiedName qualifiedName1 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      Identifier identifier2 = qualifiedName1.getOriginalSuffix();
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      doReturn(identifier1, identifier2, identifier1, identifier1, identifier0).when(sqlParameterDeclaration0).getName();
      doReturn("SHOW CREATE SCHEMA ", " type is not comparable", "%Jh~H", "SHOW FUNCTIONS", "").when(sqlParameterDeclaration0).getType();
      ImmutableList<SqlParameterDeclaration> immutableList1 = ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0);
      Optional<String> optional0 = Optional.of("");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("86^<Zm");
      RoutineCharacteristics.Determinism routineCharacteristics_Determinism0 = RoutineCharacteristics.Determinism.NOT_DETERMINISTIC;
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.CALLED_ON_NULL_INPUT;
      RoutineCharacteristics routineCharacteristics0 = new RoutineCharacteristics(routineCharacteristics_Language0, routineCharacteristics_Determinism0, routineCharacteristics_NullCallClause0);
      Return return0 = new Return(identifier1);
      CreateFunction createFunction0 = new CreateFunction(qualifiedName0, false, false, immutableList1, " IS NULL)", optional0, routineCharacteristics0, return0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(createFunction0, optional1);
      assertEquals("CREATE FUNCTION \">\".\">\".\">\".\">\".\">\".\">\".\">\".\">\".\"\".\">\".\">\" (\n   \"\" SHOW CREATE SCHEMA ,\n   \">\"  type is not comparable,\n   \"\" %Jh~H,\n   \"\" SHOW FUNCTIONS,\n   \">\" ,\n   \">\" ,\n   \">\" \n)\nRETURNS  IS NULL)\nCOMMENT ''\nLANGUAGE 86^<ZM\nNOT DETERMINISTIC\nCALLED ON NULL INPUT\nRETURN \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull1()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("rGQ");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.GRAPHVIZ;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation(18, 1616);
      Join.Type join_Type0 = Join.Type.IMPLICIT;
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      JoinCriteria joinCriteria0 = mock(JoinCriteria.class, new ViolatedAssumptionAnswer());
      Optional<JoinCriteria> optional0 = Optional.of(joinCriteria0);
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 2548);
      Optional<JoinCriteria> optional1 = optional0.filter(bloomFilter0);
      Join join0 = new Join(nodeLocation0, join_Type0, table0, table0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(join0, optional2);
      String string1 = SqlFormatter.formatSql(table0, optional2);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull1()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("rGQ");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.JSON;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation(3, 1616);
      Join.Type join_Type0 = Join.Type.CROSS;
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      JoinCriteria joinCriteria0 = mock(JoinCriteria.class, new ViolatedAssumptionAnswer());
      Optional<JoinCriteria> optional0 = Optional.of(joinCriteria0);
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 2548);
      Optional<JoinCriteria> optional1 = optional0.filter(bloomFilter0);
      Join join0 = new Join(nodeLocation0, join_Type0, table0, table0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(join0, optional2);
      assertEquals("(rGQ\nCROSS JOIN rGQ)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull0()  throws Throwable  {
      Random.setNextRandom((-14));
      System.setCurrentTimeMillis((-14));
      Random.setNextRandom(5053);
      NodeLocation nodeLocation0 = new NodeLocation((-14), 5053);
      Identifier identifier0 = new Identifier(nodeLocation0, ">", true);
      Identifier identifier1 = new Identifier("");
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier1, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      doReturn(identifier1, (Identifier) null).when(sqlParameterDeclaration0).getName();
      doReturn((String) null).when(sqlParameterDeclaration0).getType();
      ImmutableList<SqlParameterDeclaration> immutableList1 = ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0);
      Optional<String> optional0 = Optional.of("");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional1 = optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("86^<Zm");
      RoutineCharacteristics.Determinism routineCharacteristics_Determinism0 = RoutineCharacteristics.Determinism.NOT_DETERMINISTIC;
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.CALLED_ON_NULL_INPUT;
      RoutineCharacteristics routineCharacteristics0 = new RoutineCharacteristics(routineCharacteristics_Language0, routineCharacteristics_Determinism0, routineCharacteristics_NullCallClause0);
      Return return0 = new Return(identifier0);
      CreateFunction createFunction0 = new CreateFunction(qualifiedName0, true, true, immutableList1, "normalForm", optional1, routineCharacteristics0, return0);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(createFunction0, optional2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull1()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      doReturn((Identifier) null).when(sqlParameterDeclaration0).getName();
      SqlParameterDeclaration sqlParameterDeclaration1 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      ImmutableList<SqlParameterDeclaration> immutableList0 = ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration1, sqlParameterDeclaration1, sqlParameterDeclaration0, sqlParameterDeclaration1, sqlParameterDeclaration1, sqlParameterDeclaration1);
      Optional<String> optional0 = Optional.of("EXPLAdN ");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional1 = optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("GQ");
      RoutineCharacteristics.Determinism routineCharacteristics_Determinism0 = RoutineCharacteristics.Determinism.NOT_DETERMINISTIC;
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.RETURNS_NULL_ON_NULL_INPUT;
      RoutineCharacteristics routineCharacteristics0 = new RoutineCharacteristics(routineCharacteristics_Language0, routineCharacteristics_Determinism0, routineCharacteristics_NullCallClause0);
      Return return0 = new Return(currentUser0);
      QualifiedName qualifiedName0 = QualifiedName.of("EXPLAdN ");
      CreateFunction createFunction0 = new CreateFunction(qualifiedName0, true, true, immutableList0, "GQ", optional1, routineCharacteristics0, return0);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(createFunction0, optional2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull2()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      doReturn((Identifier) null).when(sqlParameterDeclaration0).getName();
      SqlParameterDeclaration sqlParameterDeclaration1 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      ImmutableList<SqlParameterDeclaration> immutableList0 = ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration1, sqlParameterDeclaration1, sqlParameterDeclaration0, sqlParameterDeclaration1, sqlParameterDeclaration1, sqlParameterDeclaration1);
      Optional<String> optional0 = Optional.of("EXPLAIN ");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional1 = optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("GQ");
      RoutineCharacteristics.Determinism routineCharacteristics_Determinism0 = RoutineCharacteristics.Determinism.NOT_DETERMINISTIC;
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.RETURNS_NULL_ON_NULL_INPUT;
      RoutineCharacteristics routineCharacteristics0 = new RoutineCharacteristics(routineCharacteristics_Language0, routineCharacteristics_Determinism0, routineCharacteristics_NullCallClause0);
      Return return0 = new Return(currentUser0);
      QualifiedName qualifiedName0 = QualifiedName.of("Epy+cc}:n#");
      CreateFunction createFunction0 = new CreateFunction(qualifiedName0, true, false, immutableList0, "Epy+cc}:n#", optional1, routineCharacteristics0, return0);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(createFunction0, optional2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull3()  throws Throwable  {
      Random.setNextRandom((-14));
      System.setCurrentTimeMillis((-14));
      Random.setNextRandom(5053);
      NodeLocation nodeLocation0 = new NodeLocation((-14), 5053);
      Identifier identifier0 = new Identifier(nodeLocation0, ">", true);
      Identifier identifier1 = new Identifier("");
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier1, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      SqlParameterDeclaration sqlParameterDeclaration0 = mock(SqlParameterDeclaration.class, new ViolatedAssumptionAnswer());
      doReturn((Identifier) null).when(sqlParameterDeclaration0).getName();
      ImmutableList<SqlParameterDeclaration> immutableList1 = ImmutableList.of(sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0, sqlParameterDeclaration0);
      Optional<String> optional0 = Optional.of("");
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional1 = optional0.or(supplier0);
      RoutineCharacteristics.Language routineCharacteristics_Language0 = new RoutineCharacteristics.Language("86^<Zm");
      RoutineCharacteristics.Determinism routineCharacteristics_Determinism0 = RoutineCharacteristics.Determinism.NOT_DETERMINISTIC;
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.CALLED_ON_NULL_INPUT;
      RoutineCharacteristics routineCharacteristics0 = new RoutineCharacteristics(routineCharacteristics_Language0, routineCharacteristics_Determinism0, routineCharacteristics_NullCallClause0);
      Return return0 = new Return(identifier0);
      CreateFunction createFunction0 = new CreateFunction(qualifiedName0, true, true, immutableList1, "normalForm", optional1, routineCharacteristics0, return0);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(createFunction0, optional2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlWithNonNull0()  throws Throwable  {
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation((-3), 19);
      Join.Type join_Type0 = Join.Type.FULL;
      Vector<Relation> vector0 = new Vector<Relation>();
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional1 = Optional.of(boolean0);
      Intersect intersect0 = new Intersect(vector0, optional1);
      JoinCriteria joinCriteria0 = mock(JoinCriteria.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(joinCriteria0).toString();
      Optional<JoinCriteria> optional2 = Optional.ofNullable(joinCriteria0);
      Join join0 = new Join(nodeLocation0, join_Type0, intersect0, intersect0, optional2);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(join0, optional0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // unknown join criteria: null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlWithNonNull1()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2317), (-2317));
      Join.Type join_Type0 = Join.Type.FULL;
      Vector<Relation> vector0 = new Vector<Relation>();
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional0 = Optional.of(boolean0);
      Intersect intersect0 = new Intersect(vector0, optional0);
      JoinCriteria joinCriteria0 = mock(JoinCriteria.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(joinCriteria0).toString();
      Optional<JoinCriteria> optional1 = Optional.ofNullable(joinCriteria0);
      Join join0 = new Join(nodeLocation0, join_Type0, intersect0, intersect0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(join0, optional2);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // unknown join criteria: null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull2()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(10, 10);
      Vector<Relation> vector0 = new Vector<Relation>();
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional0 = Optional.of(boolean0);
      Intersect intersect0 = new Intersect(vector0, optional0);
      Intersect intersect1 = new Intersect(vector0, optional0);
      Optional<JoinCriteria> optional1 = Optional.ofNullable(null);
      Join.Type join_Type0 = Join.Type.CROSS;
      Join join0 = new Join(nodeLocation0, join_Type0, intersect1, intersect0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(join0, optional2);
      assertEquals("(\nCROSS JOIN )", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull2()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("_>Xf8*\"%4r!b%.5>");
      NodeLocation nodeLocation0 = new NodeLocation(1158, 1158);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Identifier identifier0 = new Identifier("_>Xf8*\"%4r!b%.5>");
      UpdateAssignment updateAssignment0 = new UpdateAssignment(nodeLocation0, identifier0, identifier0);
      UpdateAssignment[] updateAssignmentArray0 = new UpdateAssignment[2];
      updateAssignmentArray0[0] = updateAssignment0;
      updateAssignmentArray0[1] = updateAssignment0;
      ImmutableList<UpdateAssignment> immutableList0 = ImmutableList.copyOf(updateAssignmentArray0);
      immutableList0.spliterator();
      Optional<Expression> optional0 = Optional.ofNullable(identifier0);
      Update update0 = new Update(nodeLocation0, table0, immutableList0, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(update0, optional1);
      assertEquals("UPDATE _>xf8*\"%4r!b%.5> SET\n   _>Xf8*\"%4r!b%.5> = \"_>Xf8*\"\"%4r!b%.5>\",\n   _>Xf8*\"%4r!b%.5> = \"_>Xf8*\"\"%4r!b%.5>\"\nWHERE \"_>Xf8*\"\"%4r!b%.5>\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull3()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("_>Xf8*\"%4r!b%.5>");
      NodeLocation nodeLocation0 = new NodeLocation(1158, 1158);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Identifier identifier0 = new Identifier("_>Xf8*\"%4r!b%.5>");
      UpdateAssignment updateAssignment0 = new UpdateAssignment(nodeLocation0, identifier0, identifier0);
      UpdateAssignment[] updateAssignmentArray0 = new UpdateAssignment[1];
      updateAssignmentArray0[0] = updateAssignment0;
      ImmutableList<UpdateAssignment> immutableList0 = ImmutableList.copyOf(updateAssignmentArray0);
      Optional<Expression> optional0 = Optional.ofNullable(identifier0);
      Update update0 = new Update(nodeLocation0, table0, immutableList0, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(update0, optional1);
      assertEquals("UPDATE _>xf8*\"%4r!b%.5> SET\n   _>Xf8*\"%4r!b%.5> = \"_>Xf8*\"\"%4r!b%.5>\"\nWHERE \"_>Xf8*\"\"%4r!b%.5>\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull0()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("enter   ");
      Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(643, 643);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      UpdateAssignment[] updateAssignmentArray0 = new UpdateAssignment[8];
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      Identifier identifier1 = new Identifier("");
      UpdateAssignment updateAssignment0 = new UpdateAssignment(nodeLocation0, identifier0, identifier1);
      updateAssignmentArray0[0] = updateAssignment0;
      UpdateAssignment updateAssignment1 = new UpdateAssignment(nodeLocation0, identifier1, identifier0);
      updateAssignmentArray0[1] = updateAssignment1;
      UpdateAssignment updateAssignment2 = new UpdateAssignment(identifier0, identifier0);
      updateAssignmentArray0[2] = updateAssignment2;
      UpdateAssignment updateAssignment3 = new UpdateAssignment(nodeLocation0, identifier1, identifier0);
      updateAssignmentArray0[3] = updateAssignment3;
      UpdateAssignment updateAssignment4 = new UpdateAssignment(nodeLocation0, identifier1, identifier1);
      updateAssignmentArray0[4] = updateAssignment4;
      UpdateAssignment updateAssignment5 = new UpdateAssignment(identifier0, identifier1);
      updateAssignmentArray0[5] = updateAssignment5;
      UpdateAssignment updateAssignment6 = new UpdateAssignment(identifier0, identifier1);
      updateAssignmentArray0[6] = updateAssignment6;
      UpdateAssignment updateAssignment7 = new UpdateAssignment(identifier0, identifier1);
      updateAssignmentArray0[7] = updateAssignment7;
      ImmutableList<UpdateAssignment> immutableList0 = ImmutableList.copyOf(updateAssignmentArray0);
      Optional<Expression> optional0 = Optional.ofNullable(identifier1);
      Update update0 = new Update(nodeLocation0, table0, immutableList0, optional0);
      List<UpdateAssignment> list0 = update0.getAssignments();
      Update update1 = new Update(table0, list0, optional0);
      String string0 = SqlFormatter.formatSql(update1, (Optional<List<Expression>>) null);
      assertEquals("UPDATE enter    SET\n   enter    = \"\",\n    = \"enter   \",\n   enter    = \"enter   \",\n    = \"enter   \",\n    = \"\",\n   enter    = \"\",\n   enter    = \"\",\n   enter    = \"\"\nWHERE \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull0()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)iwuY4>aq|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.JSON;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      Optional<String> optional0 = Optional.empty();
      ImmutableList<String> immutableList0 = ImmutableList.of("[{2]O&)mPV", "DROP MATERIALIZED VIEW ", "Q:$i};zl[y3F");
      ImmutableList<String> immutableList1 = immutableList0.reverse();
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(optional0, immutableList1, constraintSpecification_ConstraintType0, false, true, false);
      AddConstraint addConstraint0 = new AddConstraint(qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE ax)iwuy4>aq| ADD UNIQUE (Q:$i};zl[y3F, DROP MATERIALIZED VIEW , [{2]O&)mPV) DISABLED NOT ENFORCED", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull3()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("78^oGB8Z6\"V&u");
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      AlterColumnNotNull alterColumnNotNull0 = new AlterColumnNotNull(qualifiedName0, identifier0, false, false);
      String string0 = SqlFormatter.formatSql(alterColumnNotNull0, optional0);
      assertEquals("ALTER TABLE 78^ogb8z6\"v&u ALTER COLUMN \"78^oGB8Z6\"\"V&u\" SET NOT NULL", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull1()  throws Throwable  {
      Random.setNextRandom((-4561));
      Optional<NodeLocation> optional0 = Optional.empty();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "";
      stringArray0[1] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      DropMaterializedView dropMaterializedView0 = new DropMaterializedView(optional0, qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(dropMaterializedView0, (Optional<List<Expression>>) null);
      assertEquals("DROP MATERIALIZED VIEW IF EXISTS ..", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull2()  throws Throwable  {
      Random.setNextRandom((-4561));
      Optional<NodeLocation> optional0 = Optional.empty();
      String[] stringArray0 = new String[4];
      stringArray0[0] = "MERGE INTO ";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      DropMaterializedView dropMaterializedView0 = new DropMaterializedView(optional0, qualifiedName0, false);
      String string0 = SqlFormatter.formatSql(dropMaterializedView0, (Optional<List<Expression>>) null);
      assertEquals("DROP MATERIALIZED VIEW .merge into ...", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull4()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("78^oGB8Z6\"V&u");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.TABLE;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("Y.j *`!wUICF,:", true);
      AlterColumnNotNull alterColumnNotNull0 = new AlterColumnNotNull(qualifiedName0, identifier0, true, true);
      SqlFormatter.formatSql(alterColumnNotNull0, optional0);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull5()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("78^oGB8Z6\"V&u");
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("78^oGB8Z6\"V&u", true);
      AlterColumnNotNull alterColumnNotNull0 = new AlterColumnNotNull(qualifiedName0, identifier0, true, true);
      String string0 = SqlFormatter.formatSql(alterColumnNotNull0, optional0);
      assertEquals("ALTER TABLE IF EXISTS 78^ogb8z6\"v&u ALTER COLUMN \"78^oGB8Z6\"\"V&u\" DROP NOT NULL", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlWithNull()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      Optional<Identifier> optional0 = externalBodyReference0.getIdentifier();
      Identifier identifier0 = new Identifier("");
      ImmutableList.of(identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ImmutableList<QualifiedName> immutableList0 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList1 = ImmutableList.of(immutableList0, immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation((-4), (-4));
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional0, identifier0);
      ImmutableList<TableFunctionArgument> immutableList2 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList2, immutableList1);
      Identifier identifier1 = new Identifier("");
      AliasedRelation aliasedRelation0 = new AliasedRelation(nodeLocation0, tableFunctionInvocation0, identifier1, (List<Identifier>) null);
      Optional<List<Expression>> optional1 = Optional.empty();
      SqlFormatter.formatSql(aliasedRelation0, optional1);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql((Node) null, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull4()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName.of("@r#EED", stringArray0);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional1 = Optional.ofNullable(boolean0);
      Union union0 = new Union(immutableList0, optional1);
      String string0 = SqlFormatter.formatSql(union0, optional0);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, union0, union0);
      Union union1 = new Union(nodeLocation0, immutableList0, optional1);
      Union union2 = new Union(immutableList1, optional1);
      ImmutableList<Relation> immutableList2 = ImmutableList.of(union0, union0, union0, union0, union0, union0, union0, union1, union2, union2);
      Intersect intersect0 = new Intersect(immutableList2, optional1);
      intersect0.toString();
      Except except0 = new Except(union0, union1, optional1);
      String string1 = SqlFormatter.formatSql(except0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull5()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName.of("@r#EED", stringArray0);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional1 = Optional.ofNullable(boolean0);
      Union union0 = new Union(immutableList0, optional1);
      SqlFormatter.formatSql(union0, optional0);
      Union union1 = new Union(nodeLocation0, immutableList0, optional1);
      Union union2 = new Union(immutableList0, optional1);
      Intersect intersect0 = new Intersect(immutableList0, optional1);
      Except except0 = new Except(union0, union1, optional1);
      String string0 = SqlFormatter.formatSql(except0, optional0);
      assertEquals("EXCEPT DISTINCT ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull1()  throws Throwable  {
      QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(14, 14);
      QualifiedName.of("");
      String[] stringArray0 = new String[4];
      stringArray0[0] = "";
      stringArray0[1] = "HFF|Dw";
      stringArray0[2] = "Rv/N [L{";
      stringArray0[3] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("Rv/N [L{", stringArray0);
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      EnumLiteral enumLiteral0 = new EnumLiteral(optional0, "Rv/N [L{", "");
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "HFF|Dw", enumLiteral0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0, callArgument0, callArgument0);
      Call call0 = new Call(nodeLocation0, qualifiedName0, immutableList0);
      String string0 = SqlFormatter.formatSql(call0, (Optional<List<Expression>>) null);
      Random.setNextRandom((-4092));
      Optional<String> optional1 = Optional.empty();
      ShowFunctions showFunctions0 = new ShowFunctions(optional1, optional1);
      SqlFormatter.formatSql(showFunctions0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis((-4092));
      String string1 = SqlFormatter.formatSql(call0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull2()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("JX!F}nWV(Y+U");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(372, 372);
      Optional.of("JX!F}nWV(Y+U");
      TimeLiteral timeLiteral0 = new TimeLiteral("JX!F}nWV(Y+U");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "JX!F}nWV(Y+U", timeLiteral0);
      CallArgument callArgument1 = new CallArgument(nodeLocation0, timeLiteral0);
      CallArgument callArgument2 = new CallArgument("JX!F}nWV(Y+U", timeLiteral0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0, callArgument0, callArgument1, callArgument2, callArgument1, callArgument1);
      ImmutableList<CallArgument> immutableList1 = immutableList0.reverse();
      Object object0 = new Object();
      callArgument1.equals(object0);
      Call call0 = new Call(optional0, qualifiedName0, immutableList1);
      SqlFormatter.formatSql(call0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull6()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      Optional<Identifier> optional0 = externalBodyReference0.getIdentifier();
      SetRole.Type setRole_Type0 = SetRole.Type.ROLE;
      SetRole setRole0 = new SetRole(setRole_Type0, optional0);
      Identifier identifier0 = new Identifier("49tM$h.}");
      ImmutableList.of(identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("49tM$h.}");
      ImmutableList<QualifiedName> immutableList0 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList1 = ImmutableList.of(immutableList0, immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional0, identifier0);
      ImmutableList<TableFunctionArgument> immutableList2 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList2, immutableList1);
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      LinkedList<Relation> linkedList1 = new LinkedList<Relation>();
      linkedList1.add((Relation) tableFunctionInvocation0);
      Optional<List<String>> optional1 = Optional.empty();
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.RETURNS_NULL_ON_NULL_INPUT;
      Optional<RoutineCharacteristics.NullCallClause> optional2 = Optional.ofNullable(routineCharacteristics_NullCallClause0);
      AlterRoutineCharacteristics alterRoutineCharacteristics0 = new AlterRoutineCharacteristics(optional2);
      AlterFunction alterFunction0 = new AlterFunction(qualifiedName0, optional1, alterRoutineCharacteristics0);
      ExplainType.Type explainType_Type0 = ExplainType.Type.IO;
      ExplainType explainType0 = new ExplainType(nodeLocation0, explainType_Type0);
      ImmutableList<ExplainOption> immutableList3 = ImmutableList.of(explainType0, explainType0, explainType0, explainType0);
      Explain explain0 = new Explain(nodeLocation0, true, true, setRole0, immutableList3);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "49tM$h.}");
      ImmutableList<Expression> immutableList4 = ImmutableList.of(timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0, identifier0, timeLiteral0, timeLiteral0);
      Optional<List<Expression>> optional3 = Optional.ofNullable(immutableList4);
      String string0 = SqlFormatter.formatSql(alterFunction0, optional3);
      assertEquals("ALTER FUNCTION \"49tM$h.}\"\nRETURNS NULL ON NULL INPUT", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull3()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(396, 396);
      Optional.of("");
      NodeLocation nodeLocation1 = new NodeLocation(2846, 396);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.GRAPHVIZ;
      ExplainFormat explainFormat0 = new ExplainFormat(nodeLocation1, explainFormat_Type0);
      ImmutableList.of(explainFormat0, explainFormat0, explainFormat0);
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      DropFunction dropFunction0 = new DropFunction(qualifiedName0, optional0, false, false);
      Optional<List<String>> optional1 = dropFunction0.getParameterTypes();
      Optional<RoutineCharacteristics.NullCallClause> optional2 = Optional.empty();
      AlterRoutineCharacteristics alterRoutineCharacteristics0 = new AlterRoutineCharacteristics(optional2);
      AlterFunction alterFunction0 = new AlterFunction(qualifiedName0, optional1, alterRoutineCharacteristics0);
      ImmutableList<ExplainOption> immutableList1 = ImmutableList.of(explainFormat0, explainFormat0, explainFormat0, explainFormat0);
      Explain explain0 = new Explain(nodeLocation0, false, false, alterFunction0, immutableList1);
      String string0 = SqlFormatter.formatSql(alterFunction0, (Optional<List<Expression>>) null);
      assertEquals("ALTER FUNCTION \"\"()\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull7()  throws Throwable  {
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("Q%p?*+:}HL(D");
      Optional<List<String>> optional1 = Optional.empty();
      RoutineCharacteristics.NullCallClause routineCharacteristics_NullCallClause0 = RoutineCharacteristics.NullCallClause.CALLED_ON_NULL_INPUT;
      Optional<RoutineCharacteristics.NullCallClause> optional2 = Optional.of(routineCharacteristics_NullCallClause0);
      AlterRoutineCharacteristics alterRoutineCharacteristics0 = new AlterRoutineCharacteristics(optional2);
      AlterFunction alterFunction0 = new AlterFunction(qualifiedName0, optional1, alterRoutineCharacteristics0);
      String string0 = SqlFormatter.formatSql(alterFunction0, optional0);
      assertEquals("ALTER FUNCTION \"Q%p?*+:}HL(D\"\nCALLED ON NULL INPUT", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull8()  throws Throwable  {
      Random.setNextRandom((-7));
      Random.setNextRandom((-7));
      System.setCurrentTimeMillis(0L);
      TimeLiteral timeLiteral0 = new TimeLiteral("7\"7L3 Yyoj%yZJl");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      timeLiteral0.equals(optional0);
      NodeLocation nodeLocation0 = new NodeLocation((-7), 3654);
      ArrayList<Relation> arrayList0 = new ArrayList<Relation>();
      Optional<Boolean> optional1 = Optional.empty();
      Union union0 = new Union(nodeLocation0, arrayList0, optional1);
      ShowStats showStats0 = new ShowStats(optional0, union0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0, timeLiteral0);
      Optional<List<Expression>> optional2 = Optional.ofNullable(immutableList0);
      Supplier<Optional<List<Expression>>> supplier0 = (Supplier<Optional<List<Expression>>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<List<Expression>> optional3 = optional2.or(supplier0);
      String string0 = SqlFormatter.formatSql(showStats0, optional3);
      assertEquals("SHOW STATS FOR ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull4()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(2575, 2575);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      QualifiedName qualifiedName1 = QualifiedName.of("");
      Identifier identifier0 = qualifiedName1.getOriginalSuffix();
      List<Identifier> list0 = new ArrayList<Identifier>();
      AliasedRelation aliasedRelation0 = new AliasedRelation(nodeLocation0, table0, identifier0, list0);
      String string0 = SqlFormatter.formatSql(aliasedRelation0, (Optional<List<Expression>>) null);
      assertEquals("\"\" \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull5()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("B{<Sr:H");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(396, 396);
      Optional<String> optional0 = Optional.of("B{<Sr:H");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, immutableList0, constraintSpecification_ConstraintType0, true, true, false);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Optional<Expression> optional1 = Optional.empty();
      Delete delete0 = new Delete(table0, optional1);
      String string0 = SqlFormatter.formatSql(delete0, (Optional<List<Expression>>) null);
      assertEquals("DELETE FROM \"B{<Sr:H\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull6()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("B{<Sr:H");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(396, 396);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Optional<Expression> optional0 = Optional.empty();
      Delete delete0 = new Delete(table0, optional0);
      String string0 = SqlFormatter.formatSql(delete0, (Optional<List<Expression>>) null);
      assertEquals("DELETE FROM \"B{<Sr:H\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull7()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      Identifier identifier0 = new Identifier("9G(C4AM(lZ=? tb");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Optional.of(principalSpecification0);
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      NodeLocation nodeLocation0 = new NodeLocation(20, 20);
      SingleColumn singleColumn0 = new SingleColumn(identifier0);
      Optional<Identifier> optional0 = singleColumn0.getAlias();
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional0, identifier0);
      TableFunctionArgument[] tableFunctionArgumentArray0 = new TableFunctionArgument[3];
      tableFunctionArgumentArray0[0] = tableFunctionArgument0;
      tableFunctionArgumentArray0[1] = tableFunctionArgument0;
      tableFunctionArgumentArray0[2] = tableFunctionArgument0;
      ImmutableList<TableFunctionArgument> immutableList0 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgumentArray0);
      QualifiedName qualifiedName0 = QualifiedName.of("9G(C4AM(lZ=? tb");
      ImmutableList<QualifiedName> immutableList1 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList2 = ImmutableList.of(immutableList1, immutableList1);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList0, immutableList2);
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      LinkedList<Relation> linkedList1 = new LinkedList<Relation>();
      linkedList1.add((Relation) tableFunctionInvocation0);
      String string0 = SqlFormatter.formatSql(tableFunctionInvocation0, (Optional<List<Expression>>) null);
      assertEquals("TABLE(\"9G(C4AM(lZ=? tb\"(\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\",\n      \"9G(C4AM(lZ=? tb\"\n      COPARTITION (\"9G(C4AM(lZ=? tb\"), (\"9G(C4AM(lZ=? tb\")))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull8()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1343, 830);
      Optional.ofNullable(nodeLocation0);
      ShowStats showStats0 = new ShowStats((Relation) null);
      NodeLocation nodeLocation1 = new NodeLocation(830, (-507));
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ImmutableList<Property> immutableList0 = ImmutableList.of();
      Analyze analyze0 = new Analyze(nodeLocation1, qualifiedName0, immutableList0);
      String string0 = SqlFormatter.formatSql(analyze0, (Optional<List<Expression>>) null);
      assertEquals("ANALYZE \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull9()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ds. \u00028&N");
      NodeLocation nodeLocation0 = new NodeLocation((-359), 41);
      Table table0 = new Table(qualifiedName0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      List<Identifier> list0 = qualifiedName0.getOriginalParts();
      AliasedRelation aliasedRelation0 = new AliasedRelation(nodeLocation0, table0, identifier0, list0);
      String string0 = SqlFormatter.formatSql(aliasedRelation0, (Optional<List<Expression>>) null);
      assertEquals("\"Ds. \u00028&N\" \"Ds. \u00028&N\" (\"Ds. \u00028&N\")", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull10()  throws Throwable  {
      QualifiedName.of("B{<S42ryH");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(421, 421);
      Optional<String> optional0 = Optional.of("B{<S42ryH");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, true, true, true);
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      Optional<Boolean> optional1 = Optional.ofNullable(boolean0);
      Union union0 = new Union(nodeLocation0, linkedList0, optional1);
      Identifier identifier0 = new Identifier(" USING (");
      Optional<NodeLocation> optional2 = Optional.empty();
      Identifier identifier1 = new Identifier(optional2, "B{<S42ryH");
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier1, identifier1, identifier1, identifier0, identifier1, identifier1, identifier0);
      AliasedRelation aliasedRelation0 = new AliasedRelation(nodeLocation0, union0, identifier0, immutableList0);
      linkedList0.add((Relation) aliasedRelation0);
      String string0 = SqlFormatter.formatSql(aliasedRelation0, (Optional<List<Expression>>) null);
      assertEquals(" \" USING (\" (\"B{<S42ryH\", \"B{<S42ryH\", \"B{<S42ryH\", \" USING (\", \"B{<S42ryH\", \"B{<S42ryH\", \" USING (\")", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull11()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(2575, 2575);
      Table table0 = new Table(qualifiedName0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      ArrayList<Identifier> arrayList0 = new ArrayList<Identifier>();
      AliasedRelation aliasedRelation0 = new AliasedRelation(nodeLocation0, table0, identifier0, arrayList0);
      String string0 = SqlFormatter.formatSql(aliasedRelation0, (Optional<List<Expression>>) null);
      assertEquals("\"\" \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull0()  throws Throwable  {
      ShowStats showStats0 = new ShowStats((Relation) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(showStats0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull1()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(3260, 3260);
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      ShowStats showStats0 = new ShowStats(optional0, (Relation) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(showStats0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull6()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("{decision=");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      NodeLocation nodeLocation0 = new NodeLocation(136, 41);
      ExplainType.Type explainType_Type0 = ExplainType.Type.DISTRIBUTED;
      ExplainType explainType0 = new ExplainType(explainType_Type0);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainType0, explainType0, explainType0);
      Explain explain0 = new Explain(nodeLocation0, true, true, showCreate0, immutableList0);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(explain0, optional0);
      assertEquals("EXPLAIN ANALYZE (TYPE DISTRIBUTED, TYPE DISTRIBUTED, TYPE DISTRIBUTED)\nSHOW CREATE MATERIALIZED VIEW \"{decision=\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull12()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("TURN_OFF_LR_(OOP_ENTRY_BRANCH_OPT");
      NodeLocation nodeLocation0 = new NodeLocation(1644, 4);
      qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional.ofNullable("i68ru'oGn");
      ImmutableList<QualifiedName> immutableList0 = ImmutableList.of(qualifiedName0);
      ImmutableList.of(immutableList0);
      Stack<TableFunctionArgument> stack0 = new Stack<TableFunctionArgument>();
      Stack<List<QualifiedName>> stack1 = new Stack<List<QualifiedName>>();
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, stack0, stack1);
      String string0 = SqlFormatter.formatSql(tableFunctionInvocation0, (Optional<List<Expression>>) null);
      assertEquals("TABLE(\"TURN_OFF_LR_(OOP_ENTRY_BRANCH_OPT\"(\n))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull13()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("B{<S4RrH");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(421, 421);
      Optional<String> optional0 = Optional.of("B{<S4RrH");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, true, false, false);
      Vector<Intersect> vector0 = new Vector<Intersect>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Boolean boolean0 = Boolean.valueOf(true);
      Optional<Boolean> optional1 = Optional.ofNullable(boolean0);
      Union union0 = new Union(nodeLocation0, immutableList0, optional1);
      Table table0 = new Table(qualifiedName0);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, table0);
      Intersect intersect0 = new Intersect(immutableList1, optional1);
      String string0 = SqlFormatter.formatSql(intersect0, (Optional<List<Expression>>) null);
      assertEquals("INTERSECT DISTINCT INTERSECT DISTINCT TABLE b{<s4rrh\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull3()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("AAx)ifJr04Dr>qb");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      NodeLocation nodeLocation0 = new NodeLocation(15, 12);
      Optional.of(nodeLocation0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional<String> optional0 = Optional.ofNullable(null);
      NodeLocation nodeLocation1 = new NodeLocation(12, 41);
      ShowCatalogs showCatalogs0 = new ShowCatalogs(nodeLocation1, optional0, optional0);
      Optional<String> optional1 = showCatalogs0.getLikePattern();
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "QfZ", false, linkedList0, optional1);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0);
      Optional<String> optional2 = showCatalogs0.getEscape();
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList0, false, linkedList0, optional2);
      String string0 = SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      assertEquals("CREATE TABLE \"AAx)ifJr04Dr>qb\" (\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL,\n   \"AAx)ifJr04Dr>qb\" QfZ NOT NULL\n)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull9()  throws Throwable  {
      Optional.empty();
      Optional.empty();
      Identifier identifier0 = new Identifier("");
      QualifiedName qualifiedName0 = QualifiedName.of("~?o;RgJnG}e*^A?V ");
      NodeLocation nodeLocation0 = new NodeLocation((-1500), 180);
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "x.4F\"l$PhX=0CBQg8C", identifier0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0);
      Call call0 = new Call(nodeLocation0, qualifiedName0, immutableList0);
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.LESS_THAN;
      TableVersionExpression tableVersionExpression0 = TableVersionExpression.timestampExpression(tableVersionExpression_TableVersionOperator0, (Expression) identifier0);
      Table table0 = new Table(nodeLocation0, qualifiedName0, tableVersionExpression0);
      IfExpression ifExpression0 = new IfExpression(nodeLocation0, identifier0, tableVersionExpression0, identifier0);
      Optional<Expression> optional0 = ifExpression0.getFalseValue();
      Delete delete0 = new Delete(nodeLocation0, table0, optional0);
      Expression[] expressionArray0 = new Expression[4];
      expressionArray0[0] = (Expression) tableVersionExpression0;
      expressionArray0[1] = (Expression) tableVersionExpression0;
      expressionArray0[2] = (Expression) identifier0;
      expressionArray0[3] = (Expression) ifExpression0;
      ImmutableList<Expression> immutableList1 = ImmutableList.of(tableVersionExpression0, tableVersionExpression0, ifExpression0, identifier0, ifExpression0, tableVersionExpression0, tableVersionExpression0, tableVersionExpression0, identifier0, identifier0, tableVersionExpression0, ifExpression0, expressionArray0);
      Optional<List<Expression>> optional1 = Optional.of(immutableList1);
      String string0 = SqlFormatter.formatSql(delete0, optional1);
      assertEquals("DELETE FROM \"~?o;RgJnG}e*^A?V \" WHERE \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull10()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("_");
      QualifiedName qualifiedName0 = QualifiedName.of("_");
      NodeLocation nodeLocation0 = new NodeLocation((-1473), 180);
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.EQUAL;
      TableVersionExpression tableVersionExpression0 = TableVersionExpression.timestampExpression(tableVersionExpression_TableVersionOperator0, (Expression) identifier0);
      Table table0 = new Table(nodeLocation0, qualifiedName0, tableVersionExpression0);
      IfExpression ifExpression0 = new IfExpression(nodeLocation0, identifier0, tableVersionExpression0, identifier0);
      Optional<Expression> optional1 = ifExpression0.getFalseValue();
      Delete delete0 = new Delete(table0, optional1);
      String string0 = SqlFormatter.formatSql(delete0, optional0);
      assertEquals("DELETE FROM _ WHERE _", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlAndFormatSqlWithNonNull0()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      Identifier identifier0 = new Identifier("9G(C4AM(lZ=? tb");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Optional.of(principalSpecification0);
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      DereferenceExpression dereferenceExpression0 = new DereferenceExpression(identifier0, identifier0);
      QualifiedName qualifiedName0 = DereferenceExpression.getQualifiedName(dereferenceExpression0);
      UpdateAssignment updateAssignment0 = new UpdateAssignment(identifier0, dereferenceExpression0);
      Optional.ofNullable(dereferenceExpression0);
      SetProperties.Type setProperties_Type0 = SetProperties.Type.TABLE;
      ImmutableList<Property> immutableList0 = ImmutableList.of();
      SetProperties setProperties0 = new SetProperties(setProperties_Type0, qualifiedName0, immutableList0, true);
      SqlFormatter.formatSql(setProperties0, (Optional<List<Expression>>) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(updateAssignment0, (Optional<List<Expression>>) null);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // not yet implemented: \"9G(C4AM(lZ=? tb\" = \"9G(C4AM(lZ=? tb\".\"9G(C4AM(lZ=? tb\"
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull4()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("JX!F}3WV(Y+U");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(372, 372);
      Optional.of("JX!F}3WV(Y+U");
      SetProperties.Type setProperties_Type0 = SetProperties.Type.TABLE;
      ArrayList<Property> arrayList0 = new ArrayList<Property>();
      SetProperties setProperties0 = new SetProperties(setProperties_Type0, qualifiedName0, arrayList0, true);
      String string0 = SqlFormatter.formatSql(setProperties0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE IF EXISTS \"JX!F}3WV(Y+U\" SET PROPERTIES (  )", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull5()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      NodeLocation nodeLocation0 = new NodeLocation(4, 4);
      TableSubquery tableSubquery0 = new TableSubquery(nodeLocation0, (Query) null);
      NodeLocation nodeLocation1 = new NodeLocation(10, 4);
      SetProperties.Type setProperties_Type0 = SetProperties.Type.TABLE;
      QualifiedName qualifiedName0 = QualifiedName.of("Fj^");
      ArrayList<Property> arrayList0 = new ArrayList<Property>();
      SetProperties setProperties0 = new SetProperties(nodeLocation1, setProperties_Type0, qualifiedName0, arrayList0, false);
      setProperties0.getChildren();
      String string0 = SqlFormatter.formatSql(setProperties0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE \"Fj^\" SET PROPERTIES (  )", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull6()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 1733);
      HashSet.newHashSet(2);
      HashSet<ExplainFormat> hashSet0 = new HashSet<ExplainFormat>();
      Iterator<ExplainFormat> iterator0 = hashSet0.iterator();
      ImmutableList.copyOf(iterator0);
      String[] stringArray0 = new String[8];
      stringArray0[0] = "[a-zA-Z_]([a-zA-Z0-9_:@])*";
      stringArray0[1] = "9G(C4AM(lZ=? tb";
      stringArray0[2] = "1]q&!Y\"iX%f:";
      stringArray0[3] = "9G(C4AM(lZ=? tb";
      stringArray0[4] = "";
      stringArray0[5] = "ls(O(^";
      stringArray0[6] = "9G(C4AM(lZ=? tb";
      stringArray0[7] = "Zl>lzx0h>}]J)";
      QualifiedName qualifiedName0 = QualifiedName.of("1]q&!Y\"iX%f:", stringArray0);
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.TEXT;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainFormat0, explainFormat0, explainFormat0);
      Explain explain0 = new Explain(nodeLocation0, true, false, renameView0, immutableList0);
      SqlFormatter.formatSql(explain0, (Optional<List<Expression>>) null);
      String string0 = SqlFormatter.formatSql(explain0, (Optional<List<Expression>>) null);
      assertEquals("EXPLAIN ANALYZE (FORMAT TEXT, FORMAT TEXT, FORMAT TEXT)\nALTER VIEW \"1]q&!Y\"\"iX%f:\".\"[a-zA-Z_]([a-zA-Z0-9_:@])*\".\"9G(C4AM(lZ=? tb\".\"1]q&!Y\"\"iX%f:\".\"9G(C4AM(lZ=? tb\".\"\".\"ls(O(^\".\"9G(C4AM(lZ=? tb\".\"Zl>lzx0h>}]J)\" RENAME TO \"1]q&!Y\"\"iX%f:\".\"[a-zA-Z_]([a-zA-Z0-9_:@])*\".\"9G(C4AM(lZ=? tb\".\"1]q&!Y\"\"iX%f:\".\"9G(C4AM(lZ=? tb\".\"\".\"ls(O(^\".\"9G(C4AM(lZ=? tb\".\"Zl>lzx0h>}]J)\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull7()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("IN|U{");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.GRAPHVIZ;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation(2846, 2846);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainFormat0, explainFormat0, explainFormat0);
      Explain explain0 = new Explain(nodeLocation0, true, true, renameView0, immutableList0);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(explain0, optional0);
      assertEquals("EXPLAIN ANALYZE (FORMAT GRAPHVIZ, FORMAT GRAPHVIZ, FORMAT GRAPHVIZ)\nALTER VIEW IF EXISTS \"IN|U{\" RENAME TO \"IN|U{\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSql()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("B{<S4RrH");
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList.copyOf(iterator0);
      NodeLocation nodeLocation0 = new NodeLocation(421, 421);
      Optional<String> optional0 = Optional.of("B{<S4RrH");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, true, false, false);
      DropTag dropTag0 = new DropTag(qualifiedName0, "B{<S4RrH", true, false);
      ExplainType.Type explainType_Type0 = ExplainType.Type.VALIDATE;
      ExplainType explainType0 = new ExplainType(nodeLocation0, explainType_Type0);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainType0, explainType0, explainType0, explainType0, explainType0, explainType0, explainType0);
      Explain explain0 = new Explain(nodeLocation0, true, true, dropTag0, immutableList0);
      SqlFormatter.formatSql(explain0, (Optional<List<Expression>>) null);
      Random.setNextRandom((-1730));
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(explainType0, (Optional<List<Expression>>) null);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // not yet implemented: ExplainType{type=VALIDATE}
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull8()  throws Throwable  {
      Optional<Identifier> optional0 = Optional.empty();
      SetRole.Type setRole_Type0 = SetRole.Type.ALL;
      SetRole setRole0 = new SetRole(setRole_Type0, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(0, 40);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of();
      ImmutableList<ExplainOption> immutableList1 = immutableList0.reverse();
      Explain explain0 = new Explain(nodeLocation0, true, true, setRole0, immutableList1);
      String string0 = SqlFormatter.formatSql(explain0, optional1);
      assertEquals("EXPLAIN ANALYZE \nSET ROLE ALL", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull4()  throws Throwable  {
      Random.setNextRandom(12);
      System.setCurrentTimeMillis(1449L);
      Random.setNextRandom(12);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis((-339L));
      System.setCurrentTimeMillis(0L);
      Random.setNextRandom(12);
      Random.setNextRandom(12);
      NodeLocation nodeLocation0 = new NodeLocation(12, (-6));
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      HashSet<PrincipalSpecification> hashSet1 = new HashSet<PrincipalSpecification>();
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.of(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, hashSet1, false, optional0);
      HashSet<ExplainFormat> hashSet2 = new HashSet<ExplainFormat>();
      Iterator<ExplainFormat> iterator0 = hashSet2.iterator();
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.copyOf(iterator0);
      Explain explain0 = new Explain(nodeLocation0, false, false, grantRoles0, immutableList0);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(explain0, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull7()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)ifJY4>q|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.TEXT;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation(2846, 2846);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainFormat0, explainFormat0, explainFormat0);
      Explain explain0 = new Explain(nodeLocation0, false, false, renameView0, immutableList0);
      String string0 = SqlFormatter.formatSql(explain0, (Optional<List<Expression>>) null);
      assertEquals("EXPLAIN (FORMAT TEXT, FORMAT TEXT, FORMAT TEXT)\nALTER VIEW \"Ax)ifJY4>q|\" RENAME TO \"Ax)ifJY4>q|\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull11()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-3451), (-3451));
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#W:HDo'J{ge");
      QualifiedName qualifiedName0 = QualifiedName.of("w.A#W:HDo'J{ge");
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "w.A#W:HDo'J{ge", identifier0);
      Optional<QualifiedName> optional1 = Optional.empty();
      Optional<String> optional2 = Optional.ofNullable("w.A#W:HDo'J{ge");
      ShowTables showTables0 = new ShowTables(nodeLocation0, optional1, optional2, optional2);
      Optional<QualifiedName> optional3 = showTables0.getSchema();
      NodeLocation nodeLocation1 = new NodeLocation((-3451), (-3451));
      Stack<String> stack0 = new Stack<String>();
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation1, optional2, stack0, constraintSpecification_ConstraintType0, false, false, true);
      Optional<String> optional4 = constraintSpecification0.getConstraintName();
      ShowTables showTables1 = new ShowTables(optional3, optional2, optional4);
      Optional<String> optional5 = showTables1.getEscape();
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType1 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification1 = new ConstraintSpecification(nodeLocation0, optional5, stack0, constraintSpecification_ConstraintType1, true, false, false);
      AddConstraint addConstraint0 = new AddConstraint(qualifiedName0, true, constraintSpecification1);
      String string0 = SqlFormatter.formatSql(showTables0, optional0);
      assertEquals("SHOW TABLES LIKE U&'w.A#W:HDo''J\\007F{ge' ESCAPE U&'w.A#W:HDo''J\\007F{ge'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlAndFormatSqlWithNonNull1()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      QualifiedName qualifiedName0 = QualifiedName.of("3'd[Oy|T?oz|T");
      Optional<QualifiedName> optional1 = Optional.empty();
      Optional<String> optional2 = Optional.of("");
      ShowTables showTables0 = new ShowTables(optional1, optional2, optional2);
      Optional<String> optional3 = showTables0.getLikePattern();
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      optional2.or(supplier0);
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(iterator0);
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      NodeLocation nodeLocation0 = new NodeLocation((-209), (-209));
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional3, immutableList0, constraintSpecification_ConstraintType0, true, true, true);
      NodeLocation nodeLocation1 = new NodeLocation(8, (-209));
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation1, qualifiedName0, true, constraintSpecification0);
      qualifiedName0.getSuffix();
      SqlFormatter.formatSql(showTables0, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(constraintSpecification0, optional0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // not yet implemented: ConstraintSpecification{constraintName=Optional[], columns=[], constraintType=PRIMARY_KEY, rely=true, enabled=true, enforced=true}
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull8()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("JX!F}3WV(Y+U");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(372, 372);
      stack0.add("JX!F}3WV(Y+U");
      Optional<String> optional0 = Optional.of("JX!F}3WV(Y+U");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, false, false, false);
      stack0.add("JX!F}3WV(Y+U");
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE jx!f}3wv(y+u ADD CONSTRAINT JX!F}3WV(Y+U UNIQUE (JX!F}3WV(Y+U, JX!F}3WV(Y+U) DISABLED NOT RELY NOT ENFORCED", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull9()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(381, 381);
      Optional<String> optional0 = Optional.of("");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, false, false, false);
      stack0.add("");
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE  ADD CONSTRAINT  PRIMARY KEY () DISABLED NOT RELY NOT ENFORCED", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull12()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName.of("'TEXT'");
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      Optional<String> optional0 = Optional.of("");
      List<String> list0 = Transition.serializationNames;
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(list0);
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, immutableList0, constraintSpecification_ConstraintType0, false, false, false);
      Optional<String> optional1 = constraintSpecification0.getConstraintName();
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional2 = optional1.or(supplier0);
      ShowFunctions showFunctions0 = new ShowFunctions(optional2, optional1);
      Optional<List<Expression>> optional3 = Optional.empty();
      String string0 = SqlFormatter.formatSql(showFunctions0, optional3);
      assertEquals("SHOW FUNCTIONS LIKE '' ESCAPE ''", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull14()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("enter   ");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      Optional<String> optional0 = Optional.ofNullable("enter   ");
      ShowFunctions showFunctions0 = new ShowFunctions(optional0, optional0);
      String string0 = SqlFormatter.formatSql(showFunctions0, (Optional<List<Expression>>) null);
      assertEquals("SHOW FUNCTIONS LIKE 'enter   ' ESCAPE 'enter   '", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull10()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(381, 381);
      Optional<String> optional0 = Optional.of("");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, false, false, false);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertFalse(stack0.contains(string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull11()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-6433), (-6433));
      QualifiedName qualifiedName0 = QualifiedName.of("B8T");
      Optional<QualifiedName> optional0 = Optional.empty();
      Optional<String> optional1 = Optional.of("B8T");
      ShowTables showTables0 = new ShowTables(optional0, optional1, optional1);
      Optional<String> optional2 = showTables0.getLikePattern();
      Supplier<Optional<String>> supplier0 = (Supplier<Optional<String>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<String> optional3 = optional2.or(supplier0);
      Stack<String> stack0 = new Stack<String>();
      Iterator<String> iterator0 = stack0.iterator();
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(iterator0);
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional3, immutableList0, constraintSpecification_ConstraintType0, true, true, true);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, true, constraintSpecification0);
      qualifiedName0.getSuffix();
      SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis((-2738L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull12()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)iwuY4>aq|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.JSON;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      Optional<String> optional0 = Optional.empty();
      ImmutableList<String> immutableList0 = ImmutableList.of("[{2]O&)mPV", "DROP MATERIALIZED VIEW ", "Q:$i};zl[y3F");
      ImmutableList<String> immutableList1 = immutableList0.reverse();
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(optional0, immutableList1, constraintSpecification_ConstraintType0, false, true, false);
      AddConstraint addConstraint0 = new AddConstraint(qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertFalse(immutableList1.contains(string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull13()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      NodeLocation nodeLocation0 = new NodeLocation(1169, 1169);
      Optional.of(nodeLocation0);
      String[] stringArray0 = new String[5];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "";
      stringArray0[4] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional<String> optional0 = Optional.ofNullable("Ranges have a nonempty intersection: ");
      CreateSchema createSchema0 = new CreateSchema(nodeLocation0, qualifiedName0, false, linkedList0);
      List<Property> list0 = createSchema0.getProperties();
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "'{r", true, list0, optional0);
      LinkedHashSet<String> linkedHashSet0 = new LinkedHashSet<String>();
      Iterator<String> iterator0 = linkedHashSet0.iterator();
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(iterator0);
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(optional0, immutableList0, constraintSpecification_ConstraintType0, false, false, true);
      ImmutableList<TableElement> immutableList1 = ImmutableList.of(columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, constraintSpecification0, constraintSpecification0, columnDefinition0, columnDefinition0, constraintSpecification0, constraintSpecification0);
      NodeLocation nodeLocation1 = new NodeLocation(3804, (-1989));
      CreateTable createTable0 = new CreateTable(nodeLocation1, qualifiedName0, immutableList1, true, list0, optional0);
      SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      Random.setNextRandom(3804);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull14()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("~dxKP&2m");
      NodeLocation nodeLocation0 = new NodeLocation(1644, 4);
      Optional.of(nodeLocation0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional<String> optional0 = Optional.ofNullable("i68ru'oGn");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "~dxKP&2m", false, linkedList0, optional0);
      List<String> list0 = List.of("i68ru'oGn", "i68ru'oGn", "i68ru'oGn", "", "", "", "", "N?\"PI");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(optional0, list0, constraintSpecification_ConstraintType0, false, false, false);
      ColumnDefinition columnDefinition1 = new ColumnDefinition(nodeLocation0, identifier0, "i68ru'oGn", true, linkedList0, optional0);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0, constraintSpecification0, columnDefinition0, columnDefinition0, columnDefinition1, columnDefinition0, constraintSpecification0, columnDefinition1, constraintSpecification0, constraintSpecification0);
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList0, false, linkedList0, optional0);
      SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      Random.setNextRandom(10);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull15()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(381, 381);
      Optional<String> optional0 = Optional.of("");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.PRIMARY_KEY;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, true, true, true);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, true, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE IF EXISTS  ADD CONSTRAINT  PRIMARY KEY ()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull16()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(381, 381);
      Optional<String> optional0 = Optional.of("");
      ConstraintSpecification.ConstraintType constraintSpecification_ConstraintType0 = ConstraintSpecification.ConstraintType.UNIQUE;
      ConstraintSpecification constraintSpecification0 = new ConstraintSpecification(nodeLocation0, optional0, stack0, constraintSpecification_ConstraintType0, false, false, false);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, constraintSpecification0);
      String string0 = SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
      assertFalse(stack0.contains(string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull13()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      Optional<List<Expression>> optional0 = Optional.empty();
      Optional.empty();
      String[] stringArray0 = new String[0];
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Identifier identifier0 = new Identifier("", true);
      RenameSchema renameSchema0 = new RenameSchema(qualifiedName0, identifier0);
      String string0 = SqlFormatter.formatSql(renameSchema0, optional0);
      assertEquals("ALTER SCHEMA \"\" RENAME TO \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull14()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2174);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e");
      Optional.ofNullable(identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("w.A#>g:aFr'Z{g e");
      String string0 = identifier0.getValueLowerCase();
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "w.A#>g:aFr'Z{g e", identifier0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0);
      Call call0 = new Call(nodeLocation0, qualifiedName0, immutableList0);
      SqlFormatter.formatSql(call0, optional0);
      SqlFormatter.formatSql(call0, optional0);
      RenameSchema renameSchema0 = new RenameSchema(nodeLocation0, qualifiedName0, identifier0);
      String string1 = SqlFormatter.formatSql(renameSchema0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull9()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2174);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e");
      Optional.ofNullable(identifier0);
      Optional<String> optional1 = Optional.ofNullable("j");
      DescriptorField descriptorField0 = new DescriptorField(nodeLocation0, identifier0, optional1);
      ImmutableList<DescriptorField> immutableList0 = ImmutableList.of(descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0);
      Descriptor descriptor0 = new Descriptor(nodeLocation0, immutableList0);
      TableFunctionDescriptorArgument tableFunctionDescriptorArgument0 = TableFunctionDescriptorArgument.descriptorArgument(nodeLocation0, descriptor0);
      tableFunctionDescriptorArgument0.toString();
      System.setCurrentTimeMillis(2174);
      TableSubquery tableSubquery0 = new TableSubquery(nodeLocation0, (Query) null);
      String string0 = SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      System.setCurrentTimeMillis(2174);
      String string1 = SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull10()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2174);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e");
      Optional<String> optional1 = Optional.ofNullable("j");
      DescriptorField descriptorField0 = new DescriptorField(nodeLocation0, identifier0, optional1);
      ImmutableList<DescriptorField> immutableList0 = ImmutableList.of(descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0, descriptorField0);
      Descriptor descriptor0 = new Descriptor(nodeLocation0, immutableList0);
      TableFunctionDescriptorArgument tableFunctionDescriptorArgument0 = TableFunctionDescriptorArgument.descriptorArgument(nodeLocation0, descriptor0);
      String string0 = tableFunctionDescriptorArgument0.toString();
      System.setCurrentTimeMillis(2174);
      TableSubquery tableSubquery0 = new TableSubquery(nodeLocation0, (Query) null);
      SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      System.setCurrentTimeMillis(2174);
      String string1 = SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull11()  throws Throwable  {
      System.setCurrentTimeMillis(2780L);
      int int0 = 10;
      int int1 = 20;
      NodeLocation nodeLocation0 = new NodeLocation(10, 20);
      TableFunctionDescriptorArgument tableFunctionDescriptorArgument0 = TableFunctionDescriptorArgument.nullDescriptorArgument(nodeLocation0);
      Optional<List<Expression>> optional0 = Optional.empty();
      SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      optional0.isPresent();
      // Undeclared exception!
      try { 
        optional0.get();
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // No value present
         //
         verifyException("java.util.Optional", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull12()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation((-2698), (-2698));
      TableFunctionDescriptorArgument tableFunctionDescriptorArgument0 = TableFunctionDescriptorArgument.nullDescriptorArgument(nodeLocation0);
      String string0 = SqlFormatter.formatSql(tableFunctionDescriptorArgument0, optional0);
      assertEquals("CAST (NULL AS DESCRIPTOR)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull17()  throws Throwable  {
      System.setCurrentTimeMillis(31L);
      NodeLocation nodeLocation0 = new NodeLocation((-105), 1742);
      IntervalLiteral.Sign intervalLiteral_Sign0 = IntervalLiteral.Sign.NEGATIVE;
      IntervalLiteral.IntervalField intervalLiteral_IntervalField0 = IntervalLiteral.IntervalField.MINUTE;
      Optional<IntervalLiteral.IntervalField> optional0 = Optional.of(intervalLiteral_IntervalField0);
      IntervalLiteral intervalLiteral0 = new IntervalLiteral("frame", intervalLiteral_Sign0, intervalLiteral_IntervalField0, optional0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(intervalLiteral0, intervalLiteral0, intervalLiteral0, intervalLiteral0, intervalLiteral0);
      Values values0 = new Values(immutableList0);
      SampledRelation.Type sampledRelation_Type0 = SampledRelation.Type.BERNOULLI;
      Optional<Expression> optional1 = Optional.ofNullable(intervalLiteral0);
      LikePredicate likePredicate0 = new LikePredicate(nodeLocation0, intervalLiteral0, intervalLiteral0, optional1);
      SampledRelation sampledRelation0 = new SampledRelation(nodeLocation0, values0, sampledRelation_Type0, likePredicate0);
      String string0 = SqlFormatter.formatSql(sampledRelation0, (Optional<List<Expression>>) null);
      assertEquals(" VALUES \n  INTERVAL -  'frame' MINUTE TO MINUTE\n, INTERVAL -  'frame' MINUTE TO MINUTE\n, INTERVAL -  'frame' MINUTE TO MINUTE\n, INTERVAL -  'frame' MINUTE TO MINUTE\n, INTERVAL -  'frame' MINUTE TO MINUTE\n TABLESAMPLE BERNOULLI ((INTERVAL -  'frame' MINUTE TO MINUTE LIKE INTERVAL -  'frame' MINUTE TO MINUTE ESCAPE INTERVAL -  'frame' MINUTE TO MINUTE))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull0()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      NodeLocation nodeLocation0 = new NodeLocation(188, (-1));
      SampledRelation.Type sampledRelation_Type0 = SampledRelation.Type.BERNOULLI;
      ArithmeticUnaryExpression.Sign arithmeticUnaryExpression_Sign0 = ArithmeticUnaryExpression.Sign.MINUS;
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "");
      ArithmeticUnaryExpression arithmeticUnaryExpression0 = new ArithmeticUnaryExpression(arithmeticUnaryExpression_Sign0, timeLiteral0);
      SampledRelation sampledRelation0 = new SampledRelation(nodeLocation0, tableSubquery0, sampledRelation_Type0, arithmeticUnaryExpression0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(sampledRelation0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull18()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      currentUser0.toString();
      Identifier identifier0 = new Identifier(nodeLocation0, "Functions.forPredicate(", true);
      Identifier identifier1 = new Identifier("Functions.forPredicate(", true);
      Object object0 = new Object();
      AstVisitor<Object, Object> astVisitor0 = (AstVisitor<Object, Object>) mock(AstVisitor.class, new ViolatedAssumptionAnswer());
      currentUser0.accept(astVisitor0, astVisitor0);
      QualifiedName qualifiedName0 = QualifiedName.of("DESCRIPTOR(");
      RenameColumn renameColumn0 = new RenameColumn(qualifiedName0, identifier0, identifier1, true, false);
      String string0 = SqlFormatter.formatSql(renameColumn0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE IF EXISTS descriptor( RENAME COLUMN \"Functions.forPredicate(\" TO \"Functions.forPredicate(\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull15()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation((-410), (-6));
      CurrentUser currentUser0 = new CurrentUser();
      Expression[] expressionArray0 = new Expression[0];
      CoalesceExpression coalesceExpression0 = new CoalesceExpression(currentUser0, currentUser0, expressionArray0);
      SortItem.Ordering sortItem_Ordering0 = SortItem.Ordering.DESCENDING;
      SortItem.NullOrdering sortItem_NullOrdering0 = SortItem.NullOrdering.LAST;
      SortItem sortItem0 = new SortItem(nodeLocation0, coalesceExpression0, sortItem_Ordering0, sortItem_NullOrdering0);
      ImmutableList<SortItem> immutableList0 = ImmutableList.of(sortItem0, sortItem0, sortItem0, sortItem0);
      OrderBy orderBy0 = new OrderBy(nodeLocation0, immutableList0);
      String string0 = SqlFormatter.formatSql(orderBy0, optional0);
      assertEquals("ORDER BY COALESCE(CURRENT_USER, CURRENT_USER) DESC NULLS LAST, COALESCE(CURRENT_USER, CURRENT_USER) DESC NULLS LAST, COALESCE(CURRENT_USER, CURRENT_USER) DESC NULLS LAST, COALESCE(CURRENT_USER, CURRENT_USER) DESC NULLS LAST\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull16()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      NodeLocation nodeLocation0 = new NodeLocation((-896), (-896));
      String[] stringArray0 = new String[1];
      stringArray0[0] = " 4";
      QualifiedName.of(" 4", stringArray0);
      Identifier identifier0 = new Identifier(" 4", true);
      Optional<Identifier> optional1 = Optional.of(identifier0);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional1, identifier0);
      TableFunctionArgument[] tableFunctionArgumentArray0 = new TableFunctionArgument[8];
      tableFunctionArgumentArray0[0] = tableFunctionArgument0;
      tableFunctionArgumentArray0[1] = tableFunctionArgument0;
      tableFunctionArgumentArray0[2] = tableFunctionArgument0;
      tableFunctionArgumentArray0[3] = tableFunctionArgument0;
      tableFunctionArgumentArray0[4] = tableFunctionArgument0;
      tableFunctionArgumentArray0[5] = tableFunctionArgument0;
      NodeLocation nodeLocation1 = new NodeLocation(1762, (-1637));
      NodeLocation nodeLocation2 = new NodeLocation((-895), 636);
      TableSubquery tableSubquery0 = new TableSubquery(nodeLocation2, (Query) null);
      SortItem.Ordering sortItem_Ordering0 = SortItem.Ordering.DESCENDING;
      SortItem.NullOrdering sortItem_NullOrdering0 = SortItem.NullOrdering.UNDEFINED;
      SortItem sortItem0 = new SortItem(nodeLocation2, identifier0, sortItem_Ordering0, sortItem_NullOrdering0);
      ImmutableList<SortItem> immutableList0 = ImmutableList.of(sortItem0);
      OrderBy orderBy0 = new OrderBy(immutableList0);
      String string0 = SqlFormatter.formatSql(orderBy0, optional0);
      assertEquals("ORDER BY \" 4\" DESC\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlWithNonNull2()  throws Throwable  {
      QualifiedName.of("RE(--sudlA\"G3@=TTKi");
      Boolean boolean0 = Boolean.TRUE;
      Boolean boolean1 = Boolean.valueOf(false);
      Optional<Boolean> optional0 = Optional.of(boolean1);
      ArrayList<SampledRelation> arrayList0 = new ArrayList<SampledRelation>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(arrayList0);
      Intersect intersect0 = new Intersect(immutableList0, optional0);
      JoinCriteria joinCriteria0 = mock(JoinCriteria.class, new ViolatedAssumptionAnswer());
      doReturn((String) null).when(joinCriteria0).toString();
      Optional<JoinCriteria> optional1 = Optional.ofNullable(joinCriteria0);
      NodeLocation nodeLocation0 = new NodeLocation(5, 5);
      Join.Type join_Type0 = Join.Type.FULL;
      Union union0 = new Union(immutableList0, optional0);
      Optional<Boolean> optional2 = union0.isDistinct();
      Except except0 = new Except(intersect0, union0, optional2);
      Join join0 = new Join(nodeLocation0, join_Type0, except0, intersect0, optional1);
      Optional<List<Expression>> optional3 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(join0, optional3);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // unknown join criteria: null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNonNull0()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      Boolean boolean0 = Boolean.valueOf("CREATE TABLE ");
      Optional<Boolean> optional0 = Optional.ofNullable(boolean0);
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 1000000L);
      Optional<Boolean> optional1 = optional0.filter(bloomFilter0);
      Except except0 = new Except(tableSubquery0, tableSubquery0, optional1);
      List<Relation> list0 = except0.getRelations();
      Intersect intersect0 = new Intersect(list0, optional0);
      Optional.ofNullable(null);
      Optional<List<Expression>> optional2 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(except0, optional2);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull17()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName.of("@r#EED", stringArray0);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Boolean boolean0 = Boolean.valueOf(false);
      Optional<Boolean> optional1 = Optional.ofNullable(boolean0);
      Union union0 = new Union(immutableList0, optional1);
      String string0 = SqlFormatter.formatSql(union0, optional0);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, union0, union0);
      Union union1 = new Union(nodeLocation0, immutableList0, optional1);
      Union union2 = new Union(immutableList1, optional1);
      ImmutableList<Relation> immutableList2 = ImmutableList.of(union0, union0, union0, union0, union0, union0, union0, union1, union2, union2);
      Intersect intersect0 = new Intersect(immutableList2, optional1);
      intersect0.toString();
      Except except0 = new Except(union0, union1, optional1);
      String string1 = SqlFormatter.formatSql(except0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull2()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(tableSubquery0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlAndFormatSqlWithNull()  throws Throwable  {
      QualifiedName.of("~dxP&2m");
      Boolean boolean0 = Boolean.TRUE;
      Optional<Boolean> optional0 = Optional.of(boolean0);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Union union0 = new Union(immutableList0, optional0);
      SqlFormatter.formatSql(union0, (Optional<List<Expression>>) null);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, union0, union0);
      Intersect intersect0 = new Intersect(immutableList1, optional0);
      intersect0.toString();
      NodeLocation nodeLocation0 = new NodeLocation(1644, 4);
      TableSubquery tableSubquery0 = new TableSubquery(nodeLocation0, (Query) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(tableSubquery0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull13()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName qualifiedName0 = QualifiedName.of("X!^)6lS;");
      ImmutableList.of("", " AS ", " AS ", ".", "newDictionary must have the same position count", "", "R#LW`9E");
      Optional<List<String>> optional0 = Optional.ofNullable(null);
      NodeLocation nodeLocation1 = new NodeLocation(1, 1);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      showCreateFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      Identifier identifier0 = new Identifier("");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation0, true, optional0, false, qualifiedName0, principalSpecification0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, optional1);
      assertEquals("REVOKE GRANT OPTION FOR ALL PRIVILEGES ON x!^)6ls; FROM USER \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull15()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2174);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Random.setNextRandom(17);
      Random.setNextRandom(2174);
      System.setCurrentTimeMillis((-2070L));
      System.setCurrentTimeMillis((-2070L));
      System.setCurrentTimeMillis(17);
      System.setCurrentTimeMillis(17);
      Random.setNextRandom(2174);
      String[] stringArray0 = new String[9];
      stringArray0[0] = "SET";
      stringArray0[1] = "SET";
      stringArray0[2] = "w.A#>g:aFr'Z{g e";
      stringArray0[3] = "w.A#>g:aFr'Z{g e";
      stringArray0[4] = "SET";
      stringArray0[5] = "_^#gBO&?GV*jDha";
      stringArray0[6] = "w.A#>g:aFr'Z{g e";
      stringArray0[7] = "w.A#>g:aFr'Z{g e";
      stringArray0[8] = "SET";
      QualifiedName qualifiedName0 = QualifiedName.of("SET", stringArray0);
      qualifiedName0.getOriginalSuffix();
      NodeLocation nodeLocation1 = new NodeLocation((-639), (-930));
      Identifier identifier0 = new Identifier(nodeLocation1, "SET", true);
      Identifier identifier1 = new Identifier("SET", true);
      RenameColumn renameColumn0 = new RenameColumn(qualifiedName0, identifier0, identifier1, true, true);
      SqlFormatter.formatSql(renameColumn0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, optional0);
      Random.setNextRandom((-930));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull19()  throws Throwable  {
      Random.setNextRandom(108);
      System.setCurrentTimeMillis(108);
      Random.setNextRandom((-2628));
      Random.setNextRandom(2713);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(2713);
      System.setCurrentTimeMillis(108);
      Random.setNextRandom((-2628));
      System.setCurrentTimeMillis(100000000000000000L);
      System.setCurrentTimeMillis(3124L);
      System.setCurrentTimeMillis(108);
      System.setCurrentTimeMillis((-2628));
      Random.setNextRandom((-663));
      Random.setNextRandom(108);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(100000000000000000L);
      System.setCurrentTimeMillis((-2628));
      System.setCurrentTimeMillis(108);
      Random.setNextRandom((-639));
      String[] stringArray0 = new String[6];
      stringArray0[0] = "_^#gBO&?GV*jDha";
      stringArray0[1] = "_^#gBO&?GV*jDha";
      stringArray0[2] = "_^#gBO&?GV*jDha";
      stringArray0[3] = "_^#gBO&?GV*jDha";
      stringArray0[4] = "_^#gBO&?GV*jDha";
      stringArray0[5] = "_^#gBO&?GV*jDha";
      QualifiedName qualifiedName0 = QualifiedName.of("_^#gBO&?GV*jDha", stringArray0);
      NodeLocation nodeLocation0 = new NodeLocation(108, (-2628));
      Identifier identifier0 = new Identifier(nodeLocation0, "hH,Mx!", true);
      Identifier identifier1 = new Identifier("hH,Mx!", true);
      RenameColumn renameColumn0 = new RenameColumn(qualifiedName0, identifier0, identifier1, false, true);
      String string0 = SqlFormatter.formatSql(renameColumn0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE _^#gbo&?gv*jdha._^#gbo&?gv*jdha._^#gbo&?gv*jdha._^#gbo&?gv*jdha._^#gbo&?gv*jdha._^#gbo&?gv*jdha._^#gbo&?gv*jdha RENAME COLUMN IF EXISTS \"hH,Mx!\" TO \"hH,Mx!\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull20()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      String string0 = currentUser0.toString();
      Identifier identifier0 = new Identifier(nodeLocation0, "Functions.forPredicate(", true);
      Identifier identifier1 = new Identifier("Functions.forPredicate(", true);
      Object object0 = new Object();
      QualifiedName qualifiedName0 = QualifiedName.of("Functions.forPredicate(");
      RenameColumn renameColumn0 = new RenameColumn(qualifiedName0, identifier0, identifier0, true, true);
      String string1 = SqlFormatter.formatSql(renameColumn0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull21()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation((-8), (-8));
      Identifier identifier0 = new Identifier("");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      RenameColumn renameColumn0 = new RenameColumn(nodeLocation0, qualifiedName0, identifier0, identifier0, false, false);
      String string0 = SqlFormatter.formatSql(renameColumn0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE .. RENAME COLUMN \"\" TO \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull16()  throws Throwable  {
      QualifiedName.of("~dxP&2m");
      QualifiedName qualifiedName0 = QualifiedName.of("X!^)6lS;");
      ImmutableList<String> immutableList0 = ImmutableList.of("R#LW`9E", "R#LW`9E", "newDictionary must have the same position count", "R#LW`9E", "~dxP&2m", "wyvgZB{vSJNM$.np", "X!^)6lS;");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation((-2346), (-2346));
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      showCreateFunction0.getParameterTypes();
      Optional.empty();
      String string0 = SqlFormatter.formatSql(showCreateFunction0, (Optional<List<Expression>>) null);
      assertFalse(immutableList0.contains(string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull18()  throws Throwable  {
      System.setCurrentTimeMillis(1057L);
      System.setCurrentTimeMillis(670L);
      System.setCurrentTimeMillis((-250L));
      System.setCurrentTimeMillis(1498L);
      NodeLocation nodeLocation0 = new NodeLocation(1124, 1124);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ImmutableList<String> immutableList0 = ImmutableList.of("", "", "", "", "R#LW`9E", "Ibm5", "Ibm5");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      Optional<List<String>> optional1 = showCreateFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      Identifier identifier0 = new Identifier("");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation0, false, optional1, false, qualifiedName0, principalSpecification0);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, optional2);
      assertEquals("REVOKE , , , , R#LW`9E, Ibm5, Ibm5 ON  FROM \"\"", string0);
      
      String string1 = SqlFormatter.formatSql(showCreateFunction0, optional2);
      assertFalse(immutableList0.contains(string1));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull22()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName qualifiedName0 = QualifiedName.of("@r#EED", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "@r#EED");
      ImmutableList<String> immutableList0 = ImmutableList.of("Er,+", "`_0", "@r#EED", "@r#EED", "Ibm5", ">E9$rlNFm48Le*+M", "`~NcZ`l}d/)}2\"&");
      Optional<List<String>> optional1 = Optional.ofNullable(immutableList0);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional1);
      Optional<List<String>> optional2 = showCreateFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      Identifier identifier1 = new Identifier("`_0");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation0, true, optional2, false, qualifiedName0, principalSpecification0);
      Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, (Optional<List<Expression>>) null);
      assertEquals("REVOKE GRANT OPTION FOR Er,+, `_0, @r#EED, @r#EED, Ibm5, >E9$rlNFm48Le*+M, `~NcZ`l}d/)}2\"& ON @r#eed.@r#eed.@r#eed.@r#eed FROM \"@r#EED\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull14()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName qualifiedName0 = QualifiedName.of("X!^)6lS;");
      ImmutableList<String> immutableList0 = ImmutableList.of("", " AS ", " AS ", ".", "newDictionary must have the same position count", "", "R#LW`9E");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      NodeLocation nodeLocation1 = new NodeLocation(1, 1);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      showCreateFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      Identifier identifier0 = new Identifier("");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation0, true, optional0, false, qualifiedName0, principalSpecification0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, optional1);
      assertEquals("REVOKE GRANT OPTION FOR ,  AS ,  AS , ., newDictionary must have the same position count, , R#LW`9E ON x!^)6ls; FROM USER \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull15()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(3055L);
      System.setCurrentTimeMillis(2919L);
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation(1124, 188);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ImmutableList<String> immutableList0 = ImmutableList.of("EXPLAIN ", "", "Ibm5", "", "", "", "R#LW`9E");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      Optional<List<String>> optional1 = showCreateFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      Identifier identifier0 = new Identifier("");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation0, false, optional1, true, qualifiedName0, principalSpecification0);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, optional2);
      assertFalse(immutableList0.contains(string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull16()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("orderBy");
      Optional<List<String>> optional0 = Optional.empty();
      DropFunction dropFunction0 = new DropFunction(qualifiedName0, optional0, false, true);
      Optional<List<String>> optional1 = dropFunction0.getParameterTypes();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      NodeLocation nodeLocation0 = new NodeLocation(428, 3);
      Identifier identifier0 = new Identifier(nodeLocation0, "orderBy", true);
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(false, optional1, true, qualifiedName0, principalSpecification0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional2 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(revoke0, optional2);
      assertEquals("REVOKE ALL PRIVILEGES ON TABLE orderby FROM USER \"orderBy\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull17()  throws Throwable  {
      System.setCurrentTimeMillis((-729L));
      System.setCurrentTimeMillis((-355L));
      String[] stringArray0 = new String[0];
      ImmutableList<String> immutableList0 = ImmutableList.copyOf(stringArray0);
      Optional<List<String>> optional0 = Optional.of(immutableList0);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      NodeLocation nodeLocation0 = new NodeLocation(11, 11);
      Identifier identifier0 = new Identifier(nodeLocation0, "", true);
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(false, optional0, false, qualifiedName0, principalSpecification0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revoke0, optional1);
      assertEquals("REVOKE  ON  FROM \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull17()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional<NodeLocation> optional0 = Optional.empty();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "0,'s";
      stringArray0[1] = "0,'s";
      stringArray0[2] = "0,'s";
      stringArray0[3] = "0,'s";
      stringArray0[4] = "0,'s";
      stringArray0[5] = "0,'s";
      QualifiedName.of("0,'s", stringArray0);
      Identifier identifier0 = new Identifier(optional0, ">mP!`G a1_]nw");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional1 = Optional.of(">mP!`G a1_]nw");
      String string0 = identifier0.getCanonicalValue();
      NodeLocation nodeLocation0 = new NodeLocation(198, 2);
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "INTERSECT ", true, stack0, optional1);
      Identifier identifier1 = new Identifier(" @(");
      Optional<Identifier> optional2 = Optional.ofNullable(null);
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional2, optional1, optional1);
      ShowSchemas showSchemas1 = new ShowSchemas(nodeLocation0, optional2, optional1, optional1);
      showSchemas1.getLikePattern();
      String string1 = SqlFormatter.formatSql(showSchemas0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull19()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      Optional<List<Expression>> optional0 = Optional.empty();
      ExplainType.Type explainType_Type0 = ExplainType.Type.LOGICAL;
      ExplainType explainType0 = new ExplainType(explainType_Type0);
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainType0, explainType0, explainType0);
      NodeLocation nodeLocation0 = new NodeLocation(1748, 3898);
      Optional<Identifier> optional1 = Optional.empty();
      Optional<String> optional2 = Optional.ofNullable("namedQuery");
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional1, optional2, optional2);
      Optional<String> optional3 = showSchemas0.getLikePattern();
      ShowSession showSession0 = new ShowSession(nodeLocation0, optional3, optional2);
      Explain explain0 = new Explain(nodeLocation0, false, true, showSession0, immutableList0);
      String string0 = SqlFormatter.formatSql(showSchemas0, optional0);
      assertEquals("SHOW SCHEMAS LIKE 'namedQuery' ESCAPE 'namedQuery'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull20()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-986), (-986));
      Identifier identifier0 = new Identifier(nodeLocation0, "cYo#ZwU!w,", true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "cYo#ZwU!w,");
      Optional<Identifier> optional0 = Optional.ofNullable(identifier0);
      UnaryOperator<Identifier> unaryOperator0 = UnaryOperator.identity();
      optional0.map(unaryOperator0);
      Optional<Identifier> optional1 = Optional.empty();
      ShowRoleGrants showRoleGrants0 = new ShowRoleGrants(optional1);
      Optional<List<Expression>> optional2 = Optional.ofNullable(immutableList0);
      String string0 = SqlFormatter.formatSql(identifier0, optional2);
      String string1 = SqlFormatter.formatSql(showRoleGrants0, optional2);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull18()  throws Throwable  {
      Optional<Identifier> optional0 = Optional.empty();
      ShowRoleGrants showRoleGrants0 = new ShowRoleGrants(optional0);
      String string0 = SqlFormatter.formatSql(showRoleGrants0, (Optional<List<Expression>>) null);
      assertEquals("SHOW ROLE GRANTS", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull23()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList.of();
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.SCHEMA;
      QualifiedName qualifiedName0 = QualifiedName.of("`{>y9;o");
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      NodeLocation nodeLocation0 = new NodeLocation(1007, 1007);
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, "BEFORE");
      Identifier identifier1 = new Identifier("i](");
      identifier1.equals(showCreate0);
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier1, identifier0, identifier1, identifier1);
      QualifiedName qualifiedName1 = QualifiedName.of((Iterable<Identifier>) list0);
      DropView dropView0 = new DropView(qualifiedName1, false);
      String string0 = SqlFormatter.formatSql(dropView0, (Optional<List<Expression>>) null);
      assertEquals("DROP VIEW before.before.before.before.before.before.i](.before.i](.i](", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull18()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation((-11), (-11));
      QualifiedName qualifiedName0 = QualifiedName.of("y$wcHG");
      DropView dropView0 = new DropView(nodeLocation0, qualifiedName0, false);
      String string0 = SqlFormatter.formatSql(dropView0, optional0);
      assertEquals("DROP VIEW y$wchg", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNullAndFormatSqlWithNonNullAndFormatSqlWithNonNull0()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName qualifiedName0 = QualifiedName.of("@r#EED", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "@r#EED");
      Optional<String> optional2 = Optional.of("ShortArrayBlockBuilder(%d){positionCount=%d}");
      identifier0.getCanonicalValue();
      Property property0 = new Property(nodeLocation0, identifier0, identifier0);
      Property property1 = new Property(identifier0, identifier0);
      List<Property> list0 = List.of(property0, property0, property0, property0, property0, property0, property0, property1);
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "'ROLE'", true, list0, optional2);
      DescribeOutput describeOutput0 = new DescribeOutput(identifier0);
      SqlFormatter.formatSql(describeOutput0, optional1);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0);
      Identifier identifier1 = new Identifier("@r#EED");
      Optional<Identifier> optional3 = Optional.ofNullable(identifier1);
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional3, optional2, optional2);
      Optional<String> optional4 = showSchemas0.getLikePattern();
      ImmutableList<TableElement> immutableList1 = immutableList0.reverse();
      ShowCatalogs showCatalogs0 = new ShowCatalogs(optional0, optional4, optional2);
      Optional<String> optional5 = showCatalogs0.getLikePattern();
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList1, true, list0, optional5);
      String string0 = SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      assertEquals("CREATE TABLE IF NOT EXISTS \"@r#EED\".\"@r#EED\".\"@r#EED\".\"@r#EED\" (\n   \"@r#EED\" 'ROLE' COMMENT 'ShortArrayBlockBuilder(%d){positionCount=%d}' WITH ( \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\", \"@r#EED\" = \"@r#EED\" )\n)\nCOMMENT 'ShortArrayBlockBuilder(%d){positionCount=%d}'\nWITH (\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\",\n   \"@r#EED\" = \"@r#EED\"\n)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull19()  throws Throwable  {
      DescribeOutput describeOutput0 = new DescribeOutput((Identifier) null);
      describeOutput0.getChildren();
      String string0 = SqlFormatter.formatSql(describeOutput0, (Optional<List<Expression>>) null);
      assertEquals("DESCRIBE OUTPUT null", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull21()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList<Expression> immutableList0 = ImmutableList.of();
      QualifiedName qualifiedName0 = QualifiedName.of("`{>y9;o");
      Identifier identifier0 = new Identifier("`{>y9;o", true);
      ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName.of("`{>y9;o");
      NodeLocation nodeLocation0 = new NodeLocation(14, (-1339));
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, true, (ConstraintSpecification) null);
      Optional<List<Expression>> optional0 = Optional.ofNullable(immutableList0);
      Supplier<Optional<List<Expression>>> supplier0 = (Supplier<Optional<List<Expression>>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      optional0.or(supplier0);
      Optional<Identifier> optional1 = Optional.of(identifier0);
      Optional<String> optional2 = Optional.ofNullable(", LL_Fallback=");
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional1, optional2, optional2);
      Optional<Identifier> optional3 = showSchemas0.getCatalog();
      SingleColumn singleColumn0 = new SingleColumn(currentUser0, optional3);
      String string0 = SqlFormatter.formatSql(singleColumn0, optional0);
      assertEquals("CURRENT_USER \"`{>y9;o\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull22()  throws Throwable  {
      Optional.empty();
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation(2986, 2986);
      Identifier identifier0 = new Identifier(" LsUE ");
      SubscriptExpression subscriptExpression0 = new SubscriptExpression(identifier0, identifier0);
      DereferenceExpression dereferenceExpression0 = new DereferenceExpression(nodeLocation0, subscriptExpression0, identifier0);
      SingleColumn singleColumn0 = new SingleColumn(dereferenceExpression0, identifier0);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(singleColumn0, optional0);
      assertEquals("\" LsUE \"[\" LsUE \"].\" LsUE \" \" LsUE \"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull19()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      Optional<List<Expression>> optional0 = Optional.empty();
      SqlFormatter.formatSql(currentUser0, optional0);
      NodeLocation nodeLocation0 = new NodeLocation((-2507), (-2507));
      QualifiedName qualifiedName0 = QualifiedName.of("CURRENT_USER");
      DropView dropView0 = new DropView(nodeLocation0, qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(dropView0, optional0);
      String string1 = SqlFormatter.formatSql(dropView0, optional0);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull24()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList.of();
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.SCHEMA;
      QualifiedName qualifiedName0 = QualifiedName.of("`{>y9;o");
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      NodeLocation nodeLocation0 = new NodeLocation((-1647), 823);
      DropView dropView0 = new DropView(qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(dropView0, (Optional<List<Expression>>) null);
      assertEquals("DROP VIEW IF EXISTS `{>y9;o", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNullAndFormatSqlWithNonNullAndFormatSqlWithNonNull1()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "@r#EED";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName.of("@r#EED", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "@r#EED");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional2 = Optional.of("'ROLE'");
      identifier0.getCanonicalValue();
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "@r#EED", true, stack0, optional2);
      SqlFormatter.formatSql(identifier0, optional1);
      ImmutableList.of(columnDefinition0);
      Identifier identifier1 = new Identifier("lJj7Y");
      Optional<Identifier> optional3 = Optional.ofNullable(identifier1);
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional3, optional2, optional2);
      showSchemas0.getLikePattern();
      SqlFormatter.formatSql(showSchemas0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis(1726L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull20()  throws Throwable  {
      SetRole.Type setRole_Type0 = SetRole.Type.NONE;
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier(optional0, "");
      NodeLocation nodeLocation0 = new NodeLocation((-2757), (-2757));
      Optional<Identifier> optional1 = Optional.of(identifier0);
      Optional<String> optional2 = Optional.ofNullable("");
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional1, optional2, optional2);
      Optional<Identifier> optional3 = showSchemas0.getCatalog();
      SingleColumn singleColumn0 = new SingleColumn(identifier0, optional3);
      Optional<Identifier> optional4 = singleColumn0.getAlias();
      SetRole setRole0 = new SetRole(setRole_Type0, optional4);
      String string0 = SqlFormatter.formatSql(showSchemas0, (Optional<List<Expression>>) null);
      assertEquals("SHOW SCHEMAS FROM \"\" LIKE '' ESCAPE ''", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull21()  throws Throwable  {
      QualifiedName.of("B $wU}4e8'I`[\"=K#");
      Identifier identifier0 = new Identifier("hashTables is null");
      DescribeInput describeInput0 = new DescribeInput(identifier0);
      String string0 = SqlFormatter.formatSql(describeInput0, (Optional<List<Expression>>) null);
      assertEquals("DESCRIBE INPUT \"hashTables is null\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull23()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e", true);
      Optional<Identifier> optional2 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional2, true);
      String[] stringArray0 = new String[0];
      QualifiedName qualifiedName0 = QualifiedName.of("w.A#>g:aFr'Z{g e", stringArray0);
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      DescribeInput describeInput0 = new DescribeInput(nodeLocation0, identifier0);
      String string0 = SqlFormatter.formatSql(describeInput0, optional1);
      assertEquals("DESCRIBE INPUT \"w.A#>g:aFr'Z{g e\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull22()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Boolean boolean0 = Boolean.FALSE;
      Boolean boolean1 = Boolean.FALSE;
      Optional<Boolean> optional0 = Optional.of(boolean1);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Union union0 = new Union(immutableList0, optional0);
      SqlFormatter.formatSql(union0, (Optional<List<Expression>>) null);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, union0, union0);
      Intersect intersect0 = new Intersect(immutableList1, optional0);
      intersect0.toString();
      SqlFormatter.formatSql(intersect0, (Optional<List<Expression>>) null);
      Random.setNextRandom(2);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull23()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "WO\"H7Q,";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName qualifiedName0 = QualifiedName.of("@r#EED");
      Identifier identifier0 = new Identifier(optional0, "L/");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional2 = Optional.of("'OUTER'");
      identifier0.getCanonicalValue();
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "", false, stack0, optional2);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, false);
      String string0 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(addColumn0, optional1);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull24()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("_>Xf8*\"4r!Mb%55>");
      NodeLocation nodeLocation0 = new NodeLocation(1348, 1348);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      Optional<Identifier> optional0 = Optional.of(identifier0);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional0, identifier0);
      TableFunctionArgument tableFunctionArgument1 = new TableFunctionArgument(nodeLocation0, optional0, identifier0);
      ImmutableList<TableFunctionArgument> immutableList0 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument1, tableFunctionArgument0);
      ImmutableList<QualifiedName> immutableList1 = ImmutableList.of();
      ImmutableList<List<QualifiedName>> immutableList2 = ImmutableList.of(immutableList1, immutableList1, immutableList1, immutableList1, immutableList1, immutableList1, immutableList1, immutableList1);
      ImmutableList<List<QualifiedName>> immutableList3 = immutableList2.reverse();
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList0, immutableList3);
      String string0 = SqlFormatter.formatSql(tableFunctionInvocation0, (Optional<List<Expression>>) null);
      assertEquals("TABLE(\"_>Xf8*\"\"4r!Mb%55>\"(\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\",\n      \"_>Xf8*\"\"4r!Mb%55>\" => \"_>Xf8*\"\"4r!Mb%55>\"\n      COPARTITION (), (), (), (), (), (), (), ()))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull24()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      NodeLocation nodeLocation0 = new NodeLocation((-896), (-896));
      String[] stringArray0 = new String[14];
      stringArray0[0] = " 4";
      QualifiedName qualifiedName0 = QualifiedName.of(" 4");
      Identifier identifier0 = new Identifier(" 4");
      Optional<Identifier> optional1 = Optional.of(identifier0);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional1, identifier0);
      TableFunctionArgument[] tableFunctionArgumentArray0 = new TableFunctionArgument[8];
      tableFunctionArgumentArray0[0] = tableFunctionArgument0;
      tableFunctionArgumentArray0[1] = tableFunctionArgument0;
      tableFunctionArgumentArray0[2] = tableFunctionArgument0;
      tableFunctionArgumentArray0[3] = tableFunctionArgument0;
      tableFunctionArgumentArray0[4] = tableFunctionArgument0;
      tableFunctionArgumentArray0[5] = tableFunctionArgument0;
      tableFunctionArgumentArray0[6] = tableFunctionArgument0;
      tableFunctionArgumentArray0[7] = tableFunctionArgument0;
      ImmutableList<TableFunctionArgument> immutableList0 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgumentArray0);
      ImmutableList<QualifiedName> immutableList1 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList2 = ImmutableList.of(immutableList1);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList0, immutableList2);
      linkedList0.add((Relation) tableFunctionInvocation0);
      linkedList0.add((Relation) tableFunctionInvocation0);
      Optional<Boolean> optional2 = Optional.of(boolean0);
      Union union0 = new Union(linkedList0, optional2);
      String string0 = SqlFormatter.formatSql(union0, optional0);
      assertEquals("TABLE(\" 4\"(\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\"\n      COPARTITION (\" 4\")))UNION ALL TABLE(\" 4\"(\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\"\n      COPARTITION (\" 4\")))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull25()  throws Throwable  {
      Boolean boolean0 = Boolean.FALSE;
      Optional<Boolean> optional0 = Optional.of(boolean0);
      Vector<Lateral> vector0 = new Vector<Lateral>();
      ImmutableList<Relation> immutableList0 = ImmutableList.copyOf(vector0);
      Union union0 = new Union(immutableList0, optional0);
      ImmutableList<Relation> immutableList1 = ImmutableList.of(union0, union0, union0, union0);
      Intersect intersect0 = new Intersect(immutableList1, optional0);
      String string0 = SqlFormatter.formatSql(intersect0, (Optional<List<Expression>>) null);
      assertEquals("INTERSECT ALL INTERSECT ALL INTERSECT ALL ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull25()  throws Throwable  {
      Optional<Identifier> optional0 = Optional.empty();
      ImmutableList<QualifiedName> immutableList0 = ImmutableList.of();
      ImmutableList<List<QualifiedName>> immutableList1 = ImmutableList.of(immutableList0, immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation(1381, 1381);
      BooleanLiteral booleanLiteral0 = BooleanLiteral.FALSE_LITERAL;
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional0, booleanLiteral0);
      ImmutableList<TableFunctionArgument> immutableList2 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList2, immutableList1);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(tableFunctionInvocation0, optional1);
      assertEquals("TABLE(\"\"(\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false,\n      false\n      COPARTITION (), ()))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull26()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("u 1K");
      ImmutableList<QualifiedName> immutableList0 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList1 = ImmutableList.of(immutableList0);
      Stack<TableFunctionArgument> stack0 = new Stack<TableFunctionArgument>();
      NodeLocation nodeLocation0 = new NodeLocation(1387, 435);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, stack0, immutableList1);
      String string0 = SqlFormatter.formatSql(tableFunctionInvocation0, (Optional<List<Expression>>) null);
      assertEquals("TABLE(\"u 1K\"(\n\n      COPARTITION (\"u 1K\")))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull26()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      NodeLocation nodeLocation0 = new NodeLocation((-896), (-896));
      String[] stringArray0 = new String[1];
      stringArray0[0] = " 4";
      QualifiedName qualifiedName0 = QualifiedName.of(" 4");
      Identifier identifier0 = new Identifier(" 4");
      Optional<Identifier> optional1 = Optional.of(identifier0);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional1, identifier0);
      TableFunctionArgument[] tableFunctionArgumentArray0 = new TableFunctionArgument[8];
      tableFunctionArgumentArray0[0] = tableFunctionArgument0;
      tableFunctionArgumentArray0[1] = tableFunctionArgument0;
      tableFunctionArgumentArray0[2] = tableFunctionArgument0;
      tableFunctionArgumentArray0[3] = tableFunctionArgument0;
      tableFunctionArgumentArray0[4] = tableFunctionArgument0;
      tableFunctionArgumentArray0[5] = tableFunctionArgument0;
      tableFunctionArgumentArray0[6] = tableFunctionArgument0;
      tableFunctionArgumentArray0[7] = tableFunctionArgument0;
      ImmutableList<TableFunctionArgument> immutableList0 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgumentArray0);
      ImmutableList<QualifiedName> immutableList1 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList2 = ImmutableList.of(immutableList1);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList0, immutableList2);
      linkedList0.add((Relation) tableFunctionInvocation0);
      Optional<Boolean> optional2 = Optional.of(boolean0);
      Union union0 = new Union(linkedList0, optional2);
      String string0 = SqlFormatter.formatSql(union0, optional0);
      assertEquals("TABLE(\" 4\"(\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\",\n      \" 4\" => \" 4\"\n      COPARTITION (\" 4\")))", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull27()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      NodeLocation nodeLocation0 = new NodeLocation((-896), (-896));
      String[] stringArray0 = new String[1];
      stringArray0[0] = " 4";
      QualifiedName qualifiedName0 = QualifiedName.of(" 4", stringArray0);
      Identifier identifier0 = new Identifier(" 4", true);
      Optional<Identifier> optional1 = Optional.of(identifier0);
      TableFunctionArgument tableFunctionArgument0 = new TableFunctionArgument(nodeLocation0, optional1, identifier0);
      TableFunctionArgument[] tableFunctionArgumentArray0 = new TableFunctionArgument[8];
      tableFunctionArgumentArray0[0] = tableFunctionArgument0;
      tableFunctionArgumentArray0[1] = tableFunctionArgument0;
      tableFunctionArgumentArray0[2] = tableFunctionArgument0;
      tableFunctionArgumentArray0[3] = tableFunctionArgument0;
      tableFunctionArgumentArray0[4] = tableFunctionArgument0;
      tableFunctionArgumentArray0[5] = tableFunctionArgument0;
      tableFunctionArgumentArray0[6] = tableFunctionArgument0;
      tableFunctionArgumentArray0[7] = tableFunctionArgument0;
      ImmutableList<TableFunctionArgument> immutableList0 = ImmutableList.of(tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgument0, tableFunctionArgumentArray0);
      ImmutableList<QualifiedName> immutableList1 = ImmutableList.of(qualifiedName0);
      ImmutableList<List<QualifiedName>> immutableList2 = ImmutableList.of(immutableList1);
      TableFunctionInvocation tableFunctionInvocation0 = new TableFunctionInvocation(nodeLocation0, qualifiedName0, immutableList0, immutableList2);
      linkedList0.add((Relation) tableFunctionInvocation0);
      Optional<Boolean> optional2 = Optional.of(boolean0);
      Union union0 = new Union(linkedList0, optional2);
      SqlFormatter.formatSql(union0, optional0);
      Random.setNextRandom((-896));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull25()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "L/");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional1 = Optional.of("'OUTER'");
      String string0 = identifier0.getCanonicalValue();
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "", true, stack0, optional1);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, false);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0);
      Identifier identifier1 = new Identifier("lJj7Y");
      Optional<Identifier> optional2 = Optional.ofNullable(identifier1);
      ShowSchemas showSchemas0 = new ShowSchemas(nodeLocation0, optional2, optional1, optional1);
      Optional<String> optional3 = showSchemas0.getLikePattern();
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList0, false, stack0, optional3);
      String string1 = SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull27()  throws Throwable  {
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      Optional<Boolean> optional0 = Optional.ofNullable(boolean0);
      Intersect intersect0 = new Intersect(linkedList0, optional0);
      String string0 = SqlFormatter.formatSql(intersect0, (Optional<List<Expression>>) null);
      assertEquals("", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull28()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      Optional<Boolean> optional1 = Optional.of(boolean0);
      Union union0 = new Union(linkedList0, optional1);
      String string0 = SqlFormatter.formatSql(union0, optional0);
      assertEquals("", string0);
      
      Intersect intersect0 = new Intersect(linkedList0, optional1);
      String string1 = intersect0.toString();
      String string2 = SqlFormatter.formatSql(intersect0, optional0);
      assertFalse(string2.equals((Object)string1));
  }

  @Test(timeout = 4000)
  public void testFormatSqlReturningEmptyString()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<Relation> linkedList0 = new LinkedList<Relation>();
      Boolean boolean0 = Boolean.FALSE;
      Optional<Boolean> optional1 = Optional.of(boolean0);
      Union union0 = new Union(linkedList0, optional1);
      SqlFormatter.formatSql(union0, optional0);
      Random.setNextRandom(313);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull29()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName.of("", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "L/");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<Identifier> optional2 = Optional.empty();
      Use use0 = new Use(nodeLocation0, optional2, identifier0);
      SqlFormatter.formatSql(use0, optional1);
      SqlFormatter.formatSql(use0, optional1);
      System.setCurrentTimeMillis((-1317L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull30()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      Optional<Identifier> optional0 = externalBodyReference0.getIdentifier();
      Identifier identifier0 = new Identifier(" WITH NO DATA");
      QualifiedName.of(" WITH NO DATA");
      SetRole.Type setRole_Type0 = SetRole.Type.ALL;
      Use use0 = new Use(optional0, identifier0);
      Optional<Identifier> optional1 = use0.getCatalog();
      SetRole setRole0 = new SetRole(setRole_Type0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string0 = SqlFormatter.formatSql(use0, optional2);
      assertEquals("USE \" WITH NO DATA\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull1()  throws Throwable  {
      System.setCurrentTimeMillis((-771L));
      System.setCurrentTimeMillis((-130L));
      System.setCurrentTimeMillis((-130L));
      System.setCurrentTimeMillis((-130L));
      int int0 = (-18);
      NodeLocation nodeLocation0 = new NodeLocation(2065, (-18));
      Identifier identifier0 = new Identifier(nodeLocation0, "{Rb.h", true);
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, (ConstraintSpecification) null);
      addConstraint0.toString();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.ConstraintSpecification.getConstraintName()\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull2()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName qualifiedName0 = QualifiedName.of("'TEXT'");
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, false, (ConstraintSpecification) null);
      qualifiedName0.getSuffix();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.ConstraintSpecification.getConstraintName()\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull31()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      System.setCurrentTimeMillis(1662L);
      Optional<String> optional1 = Optional.ofNullable(" ESCAPE ");
      ShowSession showSession0 = new ShowSession(optional1, optional1);
      String string0 = SqlFormatter.formatSql(showSession0, optional0);
      assertEquals("SHOW SESSION LIKE ' ESCAPE ' ESCAPE ' ESCAPE '", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull32()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList<Expression> immutableList0 = ImmutableList.of();
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      SingleColumn singleColumn0 = new SingleColumn(currentUser0);
      NodeLocation nodeLocation0 = new NodeLocation((-2806), 2299);
      IdentityHashMap<String, String> identityHashMap0 = new IdentityHashMap<String, String>();
      VarcharEnumType.VarcharEnumMap varcharEnumType_VarcharEnumMap0 = new VarcharEnumType.VarcharEnumMap("ojKTX", identityHashMap0);
      VarcharEnumType varcharEnumType0 = new VarcharEnumType(varcharEnumType_VarcharEnumMap0);
      Optional<String> optional1 = varcharEnumType0.getEnumKeyForValue("");
      ShowSession showSession0 = new ShowSession(nodeLocation0, optional1, optional1);
      String string0 = SqlFormatter.formatSql(showSession0, optional0);
      assertEquals("SHOW SESSION", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull3()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName qualifiedName0 = QualifiedName.of("'TEXT'");
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, true, (ConstraintSpecification) null);
      qualifiedName0.getSuffix();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.ConstraintSpecification.getConstraintName()\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull4()  throws Throwable  {
      System.setCurrentTimeMillis((-771L));
      System.setCurrentTimeMillis((-130L));
      System.setCurrentTimeMillis((-130L));
      System.setCurrentTimeMillis((-130L));
      int int0 = (-18);
      NodeLocation nodeLocation0 = new NodeLocation(2065, (-18));
      Identifier identifier0 = new Identifier(nodeLocation0, "{Rb.h", true);
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) immutableList0);
      AddConstraint addConstraint0 = new AddConstraint(nodeLocation0, qualifiedName0, true, (ConstraintSpecification) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(addConstraint0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.ConstraintSpecification.getConstraintName()\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull28()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2147483645, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      String[] stringArray0 = new String[3];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "@r#EED";
      stringArray0[2] = "@r#EED";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Identifier identifier0 = new Identifier(optional0, "L/");
      Stack<Property> stack0 = new Stack<Property>();
      Property property0 = new Property(identifier0, identifier0);
      stack0.push(property0);
      Optional<String> optional2 = Optional.of("'OUTER'");
      identifier0.getCanonicalValue();
      QualifiedName.of("SHOW CATALOGS");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "", true, stack0, optional2);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, false);
      String string0 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(addColumn0, optional1);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull20()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      HashSet<PrincipalSpecification> hashSet0 = new HashSet<PrincipalSpecification>();
      Optional<Identifier> optional0 = Optional.empty();
      ShowRoles showRoles0 = new ShowRoles(optional0, false);
      NodeLocation nodeLocation0 = new NodeLocation(1735, (-9));
      SetRole.Type setRole_Type0 = SetRole.Type.NONE;
      SetRole setRole0 = new SetRole(nodeLocation0, setRole_Type0, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(showRoles0, optional1);
      assertEquals("SHOW ROLES", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull3()  throws Throwable  {
      QualifiedName.of("AfF");
      NodeLocation nodeLocation0 = new NodeLocation(13, 637);
      Identifier identifier0 = new Identifier(nodeLocation0, "AfF", false);
      MergeUpdate.Assignment mergeUpdate_Assignment0 = mock(MergeUpdate.Assignment.class, new ViolatedAssumptionAnswer());
      doReturn(identifier0, (Identifier) null).when(mergeUpdate_Assignment0).getTarget();
      doReturn(identifier0, (Expression) null).when(mergeUpdate_Assignment0).getValue();
      ImmutableList<MergeUpdate.Assignment> immutableList0 = ImmutableList.of(mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0);
      MergeUpdate mergeUpdate0 = new MergeUpdate(immutableList0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(mergeUpdate0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNonNull1()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation(2987, (-2797));
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "PO+)0xR97qfI4DBb,7");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      Identifier identifier0 = new Identifier("PO+)0xR97qfI4DBb,7");
      CurrentUser currentUser0 = new CurrentUser(nodeLocation0);
      MergeUpdate.Assignment mergeUpdate_Assignment0 = mock(MergeUpdate.Assignment.class, new ViolatedAssumptionAnswer());
      doReturn(identifier0, (Identifier) null).when(mergeUpdate_Assignment0).getTarget();
      doReturn(currentUser0, (Expression) null).when(mergeUpdate_Assignment0).getValue();
      ImmutableList<MergeUpdate.Assignment> immutableList0 = ImmutableList.of(mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0);
      MergeUpdate mergeUpdate0 = new MergeUpdate(optional0, immutableList0);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(mergeUpdate0, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull33()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-986), (-986));
      Identifier identifier0 = new Identifier("cYo#ZwU!w,", true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "cYo#ZwU!w,");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      ImmutableList.copyOf(hashSet0);
      Optional<Identifier> optional1 = Optional.ofNullable(identifier0);
      UnaryOperator<Identifier> unaryOperator0 = UnaryOperator.identity();
      Optional<Identifier> optional2 = optional1.map(unaryOperator0);
      ShowRoleGrants showRoleGrants0 = new ShowRoleGrants(optional0, optional2);
      Optional<List<Expression>> optional3 = Optional.ofNullable(immutableList0);
      SqlFormatter.formatSql(timeLiteral0, optional3);
      Identifier identifier1 = new Identifier("TL-,%B55#", true);
      Use use0 = new Use(nodeLocation0, optional2, identifier1);
      String string0 = SqlFormatter.formatSql(use0, optional3);
      assertEquals("USE \"cYo#ZwU!w,\".\"TL-,%B55#\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull29()  throws Throwable  {
      QualifiedName.of("enter   ");
      NodeLocation nodeLocation0 = new NodeLocation((-4496), 1933);
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, "enter   ");
      Optional<Identifier> optional1 = Optional.of(identifier0);
      Use use0 = new Use(optional1, identifier0);
      String string0 = SqlFormatter.formatSql(use0, (Optional<List<Expression>>) null);
      assertEquals("USE \"enter   \".\"enter   \"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull30()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e", true);
      Optional<Identifier> optional1 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional1, true);
      showRoles0.getCatalog();
      NodeLocation nodeLocation1 = new NodeLocation(0, 2174);
      SetRole.Type setRole_Type0 = SetRole.Type.ALL;
      Optional<Identifier> optional2 = Optional.empty();
      SetRole setRole0 = new SetRole(nodeLocation1, setRole_Type0, optional2);
      Optional<List<Expression>> optional3 = Optional.empty();
      String[] stringArray0 = new String[0];
      QualifiedName.of("w.A#>g:aFr'Z{g e", stringArray0);
      SqlFormatter.formatSql(showRoles0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(setRole0, optional3);
      Random.setNextRandom(2174);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull34()  throws Throwable  {
      LinkedList<MergeUpdate.Assignment> linkedList0 = new LinkedList<MergeUpdate.Assignment>();
      MergeUpdate mergeUpdate0 = new MergeUpdate(linkedList0);
      ArrayList<Expression> arrayList0 = new ArrayList<Expression>();
      Optional<List<Expression>> optional0 = Optional.of(arrayList0);
      SqlFormatter.formatSql(mergeUpdate0, optional0);
      Random.setNextRandom(2);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull4()  throws Throwable  {
      QualifiedName.of("AfF");
      MergeUpdate.Assignment mergeUpdate_Assignment0 = mock(MergeUpdate.Assignment.class, new ViolatedAssumptionAnswer());
      doReturn((Identifier) null).when(mergeUpdate_Assignment0).getTarget();
      doReturn((Expression) null).when(mergeUpdate_Assignment0).getValue();
      ImmutableList<MergeUpdate.Assignment> immutableList0 = ImmutableList.of(mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0);
      MergeUpdate mergeUpdate0 = new MergeUpdate(immutableList0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(mergeUpdate0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNonNull2()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation(2987, (-2797));
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "PO+)0xR97qfI4DBb,7");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      MergeUpdate.Assignment mergeUpdate_Assignment0 = mock(MergeUpdate.Assignment.class, new ViolatedAssumptionAnswer());
      doReturn((Identifier) null).when(mergeUpdate_Assignment0).getTarget();
      doReturn((Expression) null).when(mergeUpdate_Assignment0).getValue();
      ImmutableList<MergeUpdate.Assignment> immutableList0 = ImmutableList.of(mergeUpdate_Assignment0, mergeUpdate_Assignment0, mergeUpdate_Assignment0);
      MergeUpdate mergeUpdate0 = new MergeUpdate(optional0, immutableList0);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(mergeUpdate0, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull31()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      CallArgument callArgument0 = new CallArgument("", currentUser0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0);
      NodeLocation nodeLocation0 = new NodeLocation(1, 1);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Call call0 = new Call(nodeLocation0, qualifiedName0, immutableList0);
      String string0 = SqlFormatter.formatSql(call0, (Optional<List<Expression>>) null);
      assertEquals("CALL ( => CURRENT_USER)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull35()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Identifier identifier0 = new Identifier("w.A#>g:aFr'Z{g e", true);
      Optional<Identifier> optional2 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional2, true);
      showRoles0.getCatalog();
      NodeLocation nodeLocation1 = new NodeLocation(0, 2174);
      SetRole.Type setRole_Type0 = SetRole.Type.ALL;
      Optional<Identifier> optional3 = Optional.empty();
      SetRole setRole0 = new SetRole(nodeLocation1, setRole_Type0, optional3);
      String string0 = SqlFormatter.formatSql(identifier0, optional1);
      Optional<List<Expression>> optional4 = Optional.empty();
      String[] stringArray0 = new String[0];
      QualifiedName qualifiedName0 = QualifiedName.of("w.A#>g:aFr'Z{g e", stringArray0);
      CallArgument callArgument0 = new CallArgument(nodeLocation1, "dP8x K,Z$z-xCUd9", identifier0);
      ImmutableList<CallArgument> immutableList0 = ImmutableList.of(callArgument0);
      Call call0 = new Call(nodeLocation0, qualifiedName0, immutableList0);
      String string1 = SqlFormatter.formatSql(call0, optional4);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull32()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-1950), 0);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      String[] stringArray0 = new String[3];
      stringArray0[0] = "";
      stringArray0[1] = "W-OH7Q,";
      stringArray0[2] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Optional<NodeLocation> optional1 = Optional.of(nodeLocation0);
      Identifier identifier0 = new Identifier(optional1, "Type can be either a distinct type or parameterized");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional2 = Optional.of("'OUTER'");
      String string0 = identifier0.getCanonicalValue();
      NodeLocation nodeLocation1 = new NodeLocation((-1950), 2147483645);
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation1, identifier0, "2UuXQ<A|?[y", true, stack0, optional2);
      NodeLocation nodeLocation2 = new NodeLocation(2, 49);
      AddColumn addColumn0 = new AddColumn(nodeLocation2, qualifiedName0, columnDefinition0, false, false);
      SqlFormatter.formatSql(identifier0, optional0);
      String string1 = SqlFormatter.formatSql(addColumn0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull21()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation((-623), 1384);
      QualifiedName qualifiedName0 = QualifiedName.of("FROM");
      Identifier identifier0 = new Identifier(nodeLocation0, "FROM", true);
      Property property0 = new Property(identifier0, identifier0);
      ImmutableList<Property> immutableList0 = ImmutableList.of(property0, property0, property0, property0, property0, property0, property0, property0, property0, property0);
      Optional<String> optional1 = Optional.of("FROM");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "", false, immutableList0, optional1);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, false, false);
      String string0 = SqlFormatter.formatSql(addColumn0, optional0);
      assertEquals("ALTER TABLE from ADD COLUMN \"FROM\"  NOT NULL COMMENT 'FROM' WITH ( \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\", \"FROM\" = \"FROM\" )", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull26()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("-I[A/=j/)4");
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      qualifiedName0.getPrefix();
      Identifier identifier0 = new Identifier("!(?8ZN+BdO");
      Property property0 = new Property(identifier0, identifier0);
      linkedList0.addFirst(property0);
      CreateSchema createSchema0 = new CreateSchema(qualifiedName0, true, linkedList0);
      linkedList0.clear();
      String string0 = SqlFormatter.formatSql(createSchema0, (Optional<List<Expression>>) null);
      assertEquals("CREATE SCHEMA IF NOT EXISTS \"-I[A/=j/)4\"\nWITH (\n   \"!(?8ZN+BdO\" = \"!(?8ZN+BdO\"\n)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull22()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "W-OH7Q,";
      stringArray0[2] = "%s %s";
      stringArray0[3] = "W-OH7Q,";
      stringArray0[4] = " WITH ORDINALITY";
      stringArray0[5] = "W-OH7Q,";
      QualifiedName qualifiedName0 = QualifiedName.of("W-OH7Q,", stringArray0);
      Identifier identifier0 = new Identifier(optional0, " WITH ORDINALITY");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional2 = Optional.of(" WITH ORDINALITY");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "%s %s", false, stack0, optional2);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, false, true);
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0);
      UnmodifiableIterator<Identifier> unmodifiableIterator0 = immutableList0.iterator();
      ImmutableList.copyOf(unmodifiableIterator0);
      ImmutableList<Expression> immutableList1 = ImmutableList.copyOf(unmodifiableIterator0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      optional0.ifPresent(consumer0);
      Unnest unnest0 = new Unnest(nodeLocation0, immutableList1, false);
      unnest0.getExpressions();
      String string0 = SqlFormatter.formatSql(unnest0, optional1);
      assertEquals("UNNEST()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull23()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList<Expression> immutableList0 = ImmutableList.of();
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      SingleColumn singleColumn0 = new SingleColumn(currentUser0);
      Unnest unnest0 = new Unnest(immutableList0, false);
      String string0 = SqlFormatter.formatSql(unnest0, optional0);
      assertEquals("UNNEST()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull27()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(283, (-14));
      Optional<Identifier> optional0 = Optional.empty();
      ShowRoles showRoles0 = new ShowRoles(nodeLocation0, optional0, false);
      String string0 = SqlFormatter.formatSql(showRoles0, (Optional<List<Expression>>) null);
      assertEquals("SHOW ROLES", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull24()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Identifier identifier0 = new Identifier("W-OH7Q,", true);
      Optional<Identifier> optional2 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional2, true);
      Optional<Identifier> optional3 = showRoles0.getCatalog();
      SetRole.Type setRole_Type0 = SetRole.Type.NONE;
      SetRole setRole0 = new SetRole(nodeLocation0, setRole_Type0, optional3);
      SqlFormatter.formatSql(showRoles0, optional1);
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 2);
      optional1.filter(bloomFilter0);
      String string0 = SqlFormatter.formatSql(setRole0, optional1);
      assertEquals("SET ROLE NONE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull28()  throws Throwable  {
      Optional<Identifier> optional0 = Optional.empty();
      SetRole.Type setRole_Type0 = SetRole.Type.NONE;
      SetRole setRole0 = new SetRole(setRole_Type0, optional0);
      String string0 = SqlFormatter.formatSql(setRole0, (Optional<List<Expression>>) null);
      assertEquals("SET ROLE NONE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull36()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-986), (-986));
      Identifier identifier0 = new Identifier(nodeLocation0, "cYo#ZwU!w,", true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "cYo#ZwU!w,");
      Optional<Identifier> optional0 = Optional.ofNullable(identifier0);
      UnaryOperator<Identifier> unaryOperator0 = UnaryOperator.identity();
      Optional<Identifier> optional1 = optional0.map(unaryOperator0);
      ShowRoleGrants showRoleGrants0 = new ShowRoleGrants(nodeLocation0, optional1);
      Optional<List<Expression>> optional2 = Optional.ofNullable(immutableList0);
      String string0 = SqlFormatter.formatSql(showRoleGrants0, optional2);
      assertEquals("SHOW ROLE GRANTS FROM \"cYo#ZwU!w,\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull37()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-993), (-993));
      String[] stringArray0 = new String[2];
      stringArray0[0] = "-I[A/=j/)4";
      stringArray0[1] = "-I[A/=j/)4";
      QualifiedName qualifiedName0 = QualifiedName.of("-I[A/=j/)4", stringArray0);
      ImmutableList<String> immutableList0 = ImmutableList.of("-I[A/=j/)4", "Bad characters in base type: %s", "\n)", "", "We~*foEP^)I", "\n)", "We~*foEP^)I");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      NodeLocation nodeLocation1 = new NodeLocation(2, (-993));
      DropFunction dropFunction0 = new DropFunction(nodeLocation1, qualifiedName0, optional0, true, true);
      ImmutableList<Expression> immutableList1 = ImmutableList.of();
      Optional<List<Expression>> optional1 = Optional.of(immutableList1);
      String string0 = SqlFormatter.formatSql(dropFunction0, optional1);
      Optional<List<Expression>> optional2 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter.create(funnel0, 1306);
      Optional<NodeLocation> optional3 = Optional.of(nodeLocation0);
      Identifier identifier0 = new Identifier("We~*foEP^)I", true);
      Optional<Identifier> optional4 = Optional.ofNullable(identifier0);
      UnaryOperator<Identifier> unaryOperator0 = UnaryOperator.identity();
      Optional<Identifier> optional5 = optional4.map(unaryOperator0);
      ShowRoleGrants showRoleGrants0 = new ShowRoleGrants(optional3, optional5);
      String string1 = SqlFormatter.formatSql(showRoleGrants0, optional2);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull25()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.ofNullable(grantorSpecification0);
      String[] stringArray0 = new String[5];
      stringArray0[0] = " RECURSIVE";
      stringArray0[1] = "o0";
      stringArray0[2] = "o0";
      stringArray0[3] = "o0";
      stringArray0[4] = "o0";
      QualifiedName qualifiedName0 = QualifiedName.of("o0", stringArray0);
      ImmutableList<String> immutableList0 = ImmutableList.of("q|/o", "o0", "/YT(SAt<Vycvv_47", "o0", "", " RECURSIVE", "o0");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation(0, 578);
      DropFunction dropFunction0 = new DropFunction(nodeLocation0, qualifiedName0, optional0, false, false);
      ImmutableList<Expression> immutableList1 = ImmutableList.of();
      Optional<List<Expression>> optional1 = Optional.of(immutableList1);
      SqlFormatter.formatSql(dropFunction0, optional1);
      Optional.empty();
      // Undeclared exception!
      try { 
        BloomFilter.create(null, 578);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull26()  throws Throwable  {
      String[] stringArray0 = new String[5];
      stringArray0[0] = " RECURSIVE";
      stringArray0[1] = "o0";
      stringArray0[2] = "o0";
      stringArray0[3] = "o0";
      stringArray0[4] = "o0";
      QualifiedName qualifiedName0 = QualifiedName.of("o0", stringArray0);
      ImmutableList<String> immutableList0 = ImmutableList.of("q|/o", "o0", "/YT(SAt<Vycvv_47", "o0", "", " RECURSIVE", "o0");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation(0, 578);
      DropFunction dropFunction0 = new DropFunction(nodeLocation0, qualifiedName0, optional0, false, false);
      ImmutableList<Expression> immutableList1 = ImmutableList.of();
      Optional<List<Expression>> optional1 = Optional.of(immutableList1);
      SqlFormatter.formatSql(dropFunction0, optional1);
      Optional.empty();
      // Undeclared exception!
      try { 
        BloomFilter.create(null, 578);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull27()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList<Expression> immutableList0 = ImmutableList.of();
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      SingleColumn singleColumn0 = new SingleColumn(currentUser0);
      Unnest unnest0 = new Unnest(immutableList0, true);
      String string0 = SqlFormatter.formatSql(unnest0, optional0);
      assertEquals("UNNEST() WITH ORDINALITY", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull28()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter.create(funnel0, 2174);
      String[] stringArray0 = new String[6];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "W-OH7Q,";
      stringArray0[2] = "%s %s";
      stringArray0[3] = "W-OH7Q,";
      stringArray0[4] = " WITH ORDINALITY";
      stringArray0[5] = "W-OH7Q,";
      QualifiedName qualifiedName0 = QualifiedName.of("W-OH7Q,", stringArray0);
      Identifier identifier0 = new Identifier(optional0, " WITH ORDINALITY");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional1 = Optional.of(" WITH ORDINALITY");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "%s %s", true, stack0, optional1);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, true);
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0);
      UnmodifiableIterator<Identifier> unmodifiableIterator0 = immutableList0.iterator();
      ImmutableList.copyOf(unmodifiableIterator0);
      ImmutableList<Expression> immutableList1 = ImmutableList.copyOf(unmodifiableIterator0);
      Unnest unnest0 = new Unnest(nodeLocation0, immutableList1, true);
      List<Expression> list0 = unnest0.getExpressions();
      Optional<List<Expression>> optional2 = Optional.of(list0);
      String string0 = SqlFormatter.formatSql(unnest0, optional2);
      assertEquals("UNNEST() WITH ORDINALITY", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull29()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(4925, 4925);
      QualifiedName qualifiedName0 = QualifiedName.of("@9!");
      Optional<NodeLocation> optional1 = Optional.empty();
      Identifier identifier0 = new Identifier(optional1, "");
      Property property0 = new Property(nodeLocation0, identifier0, identifier0);
      ImmutableList<Property> immutableList0 = ImmutableList.of(property0);
      Optional<String> optional2 = Optional.of("");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(identifier0, "y`%b)rJmy", true, immutableList0, optional2);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, true);
      String string0 = SqlFormatter.formatSql(addColumn0, optional0);
      assertEquals("ALTER TABLE IF EXISTS @9! ADD COLUMN IF NOT EXISTS \"\" y`%b)rJmy COMMENT '' WITH ( \"\" = \"\" )", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull29()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("~dxKP&2m");
      NodeLocation nodeLocation0 = new NodeLocation(1644, 3);
      Optional.of(nodeLocation0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional<String> optional0 = Optional.ofNullable("i68ru'oGn");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "i68ru'oGn", true, linkedList0, optional0);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0);
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList0, true, linkedList0, optional0);
      String string0 = SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      assertEquals("CREATE TABLE IF NOT EXISTS \"~dxKP&2m\" (\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn COMMENT 'i68ru''oGn'\n)\nCOMMENT 'i68ru''oGn'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull30()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("~dxKP&2m");
      NodeLocation nodeLocation0 = new NodeLocation(1644, 4);
      Optional.of(nodeLocation0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      Optional<String> optional0 = Optional.ofNullable("i68ru'oGn");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "i68ru'oGn", false, linkedList0, optional0);
      ImmutableList<TableElement> immutableList0 = ImmutableList.of(columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0, columnDefinition0);
      CreateTable createTable0 = new CreateTable(nodeLocation0, qualifiedName0, immutableList0, false, linkedList0, optional0);
      String string0 = SqlFormatter.formatSql(createTable0, (Optional<List<Expression>>) null);
      assertEquals("CREATE TABLE \"~dxKP&2m\" (\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn',\n   \"~dxKP&2m\" i68ru'oGn NOT NULL COMMENT 'i68ru''oGn'\n)\nCOMMENT 'i68ru''oGn'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull31()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter.create(funnel0, 2174);
      String[] stringArray0 = new String[6];
      stringArray0[0] = "W-OH7Q,";
      stringArray0[1] = "W-OH7Q,";
      stringArray0[2] = "%s %s";
      stringArray0[3] = "W-OH7Q,";
      stringArray0[4] = " WITH ORDINALITY";
      stringArray0[5] = "W-OH7Q,";
      QualifiedName qualifiedName0 = QualifiedName.of("W-OH7Q,", stringArray0);
      Identifier identifier0 = new Identifier(optional0, " WITH ORDINALITY");
      Stack<Property> stack0 = new Stack<Property>();
      Optional<String> optional1 = Optional.of(" WITH ORDINALITY");
      ColumnDefinition columnDefinition0 = new ColumnDefinition(nodeLocation0, identifier0, "%s %s", true, stack0, optional1);
      AddColumn addColumn0 = new AddColumn(nodeLocation0, qualifiedName0, columnDefinition0, true, true);
      SqlFormatter.formatSql(addColumn0, (Optional<List<Expression>>) null);
      Random.setNextRandom(412);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull32()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      QualifiedName.of("mpCO27");
      QualifiedName qualifiedName0 = QualifiedName.of("*Z:w^m#0wjM4{?/OU");
      NodeLocation nodeLocation0 = new NodeLocation((-8), (-8));
      DropSchema dropSchema0 = new DropSchema(nodeLocation0, qualifiedName0, true, false);
      dropSchema0.toString();
      SqlFormatter.formatSql(dropSchema0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis(149795463772692060L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull38()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-993), (-993));
      Identifier identifier0 = new Identifier("cYpo#ZU!w,", true);
      hashSet0.add(identifier0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "#";
      stringArray0[1] = "#";
      stringArray0[2] = "#";
      stringArray0[3] = "#";
      QualifiedName.of("#", stringArray0);
      Identifier identifier1 = new Identifier("#", true);
      Identifier identifier2 = new Identifier(nodeLocation0, "#", true);
      hashSet0.add(identifier2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      ImmutableList<Expression> immutableList1 = ImmutableList.copyOf(immutableList0);
      Values values0 = new Values(immutableList1);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      SqlFormatter.formatSql(values0, optional0);
      String string0 = SqlFormatter.formatSql(identifier2, optional0);
      assertEquals("\"#\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull33()  throws Throwable  {
      QualifiedName.of(" WITHO: GRANT OPTI1N");
      QualifiedName qualifiedName0 = QualifiedName.of("*Z:w^m#0wjM4{?/OU");
      NodeLocation nodeLocation0 = new NodeLocation(1495, 1495);
      DropSchema dropSchema0 = new DropSchema(nodeLocation0, qualifiedName0, false, true);
      dropSchema0.toString();
      SqlFormatter.formatSql(dropSchema0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis((-2305984914950063505L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull34()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("zbL4S&8'Hn#T{ctBM)");
      NodeLocation nodeLocation0 = new NodeLocation(3, 3);
      DropSchema dropSchema0 = new DropSchema(nodeLocation0, qualifiedName0, false, true);
      String string0 = SqlFormatter.formatSql(dropSchema0, (Optional<List<Expression>>) null);
      assertEquals("DROP SCHEMA \"zbL4S&8'Hn#T{ctBM)\" CASCADE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull35()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      DropSchema dropSchema0 = new DropSchema(qualifiedName0, true, false);
      String string0 = SqlFormatter.formatSql(dropSchema0, (Optional<List<Expression>>) null);
      assertEquals("DROP SCHEMA IF EXISTS \"\" RESTRICT", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull30()  throws Throwable  {
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.toArray();
      NodeLocation nodeLocation0 = new NodeLocation((-9), (-9));
      Identifier identifier0 = new Identifier(nodeLocation0, "cYo#ZwU!w,", true);
      TimestampLiteral timestampLiteral0 = new TimestampLiteral(nodeLocation0, " = ");
      ImmutableList<Expression> immutableList0 = ImmutableList.of(timestampLiteral0, identifier0, identifier0, timestampLiteral0);
      TimeLiteral timeLiteral0 = new TimeLiteral("GRANT OPTION FOR ");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      Comparator<Object> comparator0 = (Comparator<Object>) mock(Comparator.class, new ViolatedAssumptionAnswer());
      PriorityQueue<Identifier> priorityQueue0 = new PriorityQueue<Identifier>(comparator0);
      ImmutableList.copyOf(priorityQueue0);
      Vector<Identifier> vector0 = new Vector<Identifier>();
      MergeInsert mergeInsert0 = new MergeInsert(optional0, vector0, immutableList0);
      Optional<List<Expression>> optional1 = Optional.of(immutableList0);
      QualifiedName qualifiedName0 = QualifiedName.of(" = ");
      DropSchema dropSchema0 = new DropSchema(nodeLocation0, qualifiedName0, true, true);
      SqlFormatter.formatSql(dropSchema0, optional1);
      System.setCurrentTimeMillis((-2305984914950063505L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull31()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("AfF");
      NodeLocation nodeLocation0 = new NodeLocation((-2200), (-2200));
      CreateType createType0 = new CreateType(qualifiedName0, "SingleRowBlock(%d){numFields=%d}");
      List<String> list0 = createType0.getParameterNames();
      Optional<List<String>> optional0 = Optional.ofNullable(list0);
      DropFunction dropFunction0 = new DropFunction(nodeLocation0, qualifiedName0, optional0, false, true);
      Optional<List<String>> optional1 = dropFunction0.getParameterTypes();
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional1);
      IntervalLiteral.Sign intervalLiteral_Sign0 = IntervalLiteral.Sign.NEGATIVE;
      IntervalLiteral.IntervalField intervalLiteral_IntervalField0 = IntervalLiteral.IntervalField.YEAR;
      Optional<IntervalLiteral.IntervalField> optional2 = Optional.empty();
      IntervalLiteral intervalLiteral0 = new IntervalLiteral(nodeLocation0, "XB(", intervalLiteral_Sign0, intervalLiteral_IntervalField0, optional2);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(intervalLiteral0, intervalLiteral0, intervalLiteral0, intervalLiteral0, intervalLiteral0);
      intervalLiteral0.equals(dropFunction0);
      Optional<List<Expression>> optional3 = Optional.ofNullable(immutableList0);
      String string0 = SqlFormatter.formatSql(dropFunction0, optional3);
      assertEquals("DROP FUNCTION IF EXISTS AfF()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull33()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("B $wU}4e8'I`[\"=K#");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      NodeLocation nodeLocation0 = new NodeLocation(2729, 849);
      ArrayList<String> arrayList0 = new ArrayList<String>();
      Optional<List<String>> optional0 = Optional.of(arrayList0);
      ShowCreateFunction showCreateFunction0 = new ShowCreateFunction(nodeLocation0, qualifiedName0, optional0);
      Optional<List<String>> optional1 = showCreateFunction0.getParameterTypes();
      Optional<RoutineCharacteristics.NullCallClause> optional2 = Optional.empty();
      AlterRoutineCharacteristics alterRoutineCharacteristics0 = new AlterRoutineCharacteristics(optional2);
      AlterFunction alterFunction0 = new AlterFunction(nodeLocation0, qualifiedName0, optional1, alterRoutineCharacteristics0);
      String string0 = SqlFormatter.formatSql(alterFunction0, (Optional<List<Expression>>) null);
      assertEquals("ALTER FUNCTION \"B $wU}4e8'I`[\"\"=K#\"()\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull32()  throws Throwable  {
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation((-1500), 180);
      System.setCurrentTimeMillis(3179L);
      NodeLocation nodeLocation1 = new NodeLocation(1256, 32);
      Optional<List<String>> optional1 = Optional.empty();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      Identifier identifier0 = new Identifier("constraintRely");
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      Revoke revoke0 = new Revoke(nodeLocation1, false, optional1, true, qualifiedName0, principalSpecification0);
      Optional<List<String>> optional2 = revoke0.getPrivileges();
      DropFunction dropFunction0 = new DropFunction(nodeLocation1, qualifiedName0, optional2, true, true);
      String string0 = SqlFormatter.formatSql(dropFunction0, optional0);
      assertEquals("DROP TEMPORARY FUNCTION IF EXISTS \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull33()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-993), (-993));
      Identifier identifier0 = new Identifier("cYo#ZwU!w,", true);
      hashSet0.add(identifier0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "#";
      stringArray0[1] = "#";
      stringArray0[2] = "#";
      stringArray0[3] = "#";
      QualifiedName qualifiedName0 = QualifiedName.of("#", stringArray0);
      ImmutableList<String> immutableList0 = ImmutableList.of("cYo#ZwU!w,", "#", "\n)", "\n)", "oo1 ", "", "@sK|~@3jNJA8(3");
      Optional<List<String>> optional0 = Optional.ofNullable(immutableList0);
      DropFunction dropFunction0 = new DropFunction(nodeLocation0, qualifiedName0, optional0, true, true);
      ImmutableList<Expression> immutableList1 = ImmutableList.of();
      Optional<List<Expression>> optional1 = Optional.of(immutableList1);
      SqlFormatter.formatSql(dropFunction0, optional1);
      Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 2);
      optional1.filter(bloomFilter0);
      Optional<QualifiedName> optional2 = Optional.ofNullable(qualifiedName0);
      Supplier<Optional<QualifiedName>> supplier0 = (Supplier<Optional<QualifiedName>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<QualifiedName> optional3 = optional2.or(supplier0);
      ShowTables showTables0 = null;
      try {
        showTables0 = new ShowTables(nodeLocation0, optional3, (Optional<String>) null, (Optional<String>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // likePattern is null
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull34()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      Optional<NodeLocation> optional0 = Optional.empty();
      Optional<List<Expression>> optional1 = Optional.empty();
      Identifier identifier0 = new Identifier(optional0, "5");
      Optional<Identifier> optional2 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional2, false);
      showRoles0.getCatalog();
      Optional<List<Expression>> optional3 = null;
      Optional.empty();
      optional1.stream();
      SqlFormatter.formatSql(showRoles0, optional1);
      Stack<SortItem> stack0 = new Stack<SortItem>();
      OrderBy orderBy0 = null;
      try {
        orderBy0 = new OrderBy(stack0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // sortItems should not be empty
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull35()  throws Throwable  {
      QualifiedName.of("\"N$$m|-|>n)");
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(2231, 2231);
      Optional<Identifier> optional1 = Optional.empty();
      ShowRoles showRoles0 = new ShowRoles(nodeLocation0, optional1, true);
      String string0 = SqlFormatter.formatSql(showRoles0, optional0);
      assertEquals("SHOW CURRENT ROLES", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull36()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of(" WITHO: GRANT OPTI1N");
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      Optional<Identifier> optional0 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, true);
      Optional<List<Expression>> optional1 = Optional.empty();
      optional1.stream();
      String string0 = SqlFormatter.formatSql(showRoles0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CURRENT ROLES FROM \" WITHO: GRANT OPTI1N\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull36()  throws Throwable  {
      Identifier identifier0 = new Identifier("@r#EED");
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      TreeSet<Identifier> treeSet0 = new TreeSet<Identifier>();
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier1 = new Identifier("@r#EED", true);
      Optional<Identifier> optional1 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional1, true);
      showRoles0.getCatalog();
      Optional<List<Expression>> optional2 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 335);
      optional2.filter(bloomFilter0);
      SqlFormatter.formatSql(showRoles0, optional2);
      System.setCurrentTimeMillis((-3596L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull34()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2174, 2);
      SetRole.Type setRole_Type0 = SetRole.Type.ROLE;
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("Of%(Nqfs", true);
      Optional<Identifier> optional1 = Optional.ofNullable(identifier0);
      ShowRoles showRoles0 = new ShowRoles(optional0, optional1, true);
      Optional<Identifier> optional2 = showRoles0.getCatalog();
      SetRole setRole0 = new SetRole(nodeLocation0, setRole_Type0, optional2);
      SqlFormatter.formatSql(setRole0, (Optional<List<Expression>>) null);
      Optional<List<Expression>> optional3 = Optional.empty();
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      BloomFilter<Object> bloomFilter0 = BloomFilter.create(funnel0, 2174);
      Optional<List<Expression>> optional4 = optional3.filter(bloomFilter0);
      SqlFormatter.formatSql(setRole0, optional4);
      System.setCurrentTimeMillis(2174);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull37()  throws Throwable  {
      SetRole.Type setRole_Type0 = SetRole.Type.ALL;
      Optional<Identifier> optional0 = Optional.empty();
      SetRole setRole0 = new SetRole(setRole_Type0, optional0);
      String string0 = SqlFormatter.formatSql(setRole0, (Optional<List<Expression>>) null);
      assertEquals("SET ROLE ALL", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNoSuchElementException0()  throws Throwable  {
      Optional<Identifier> optional0 = Optional.empty();
      SetRole.Type setRole_Type0 = SetRole.Type.ROLE;
      SetRole setRole0 = new SetRole(setRole_Type0, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(setRole0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // No value present
         //
         verifyException("java.util.Optional", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull39()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-986), (-986));
      Identifier identifier0 = new Identifier(nodeLocation0, "cYo#ZwU!w,", true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      TimeLiteral timeLiteral0 = new TimeLiteral("hH >F/G?i7l6*]~[@G");
      Optional<NodeLocation> optional0 = timeLiteral0.getLocation();
      ImmutableList<Identifier> immutableList1 = ImmutableList.copyOf(hashSet0);
      MergeInsert mergeInsert0 = new MergeInsert(optional0, immutableList1, immutableList0);
      Optional<List<Expression>> optional1 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(mergeInsert0, optional1);
      assertEquals("WHEN NOT MATCHED THEN\n   INSERT \n   VALUES (\"cYo#ZwU!w,\", \"cYo#ZwU!w,\", \"cYo#ZwU!w,\", \"cYo#ZwU!w,\")", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull40()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      ImmutableList<Expression> immutableList0 = ImmutableList.of();
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      SingleColumn singleColumn0 = new SingleColumn(currentUser0);
      String string0 = SqlFormatter.formatSql(singleColumn0, optional0);
      assertEquals("CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull37()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-986), (-986));
      Identifier identifier0 = new Identifier("cYo#ZwU!w,", true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, "cYo#ZwU!w,");
      Optional<Identifier> optional0 = Optional.ofNullable(identifier0);
      UnaryOperator<Identifier> unaryOperator0 = UnaryOperator.identity();
      optional0.map(unaryOperator0);
      Optional<List<Expression>> optional1 = Optional.ofNullable(immutableList0);
      Identifier identifier1 = new Identifier("cYo#ZwU!w,", true);
      Use use0 = new Use(optional0, identifier0);
      AllColumns allColumns0 = new AllColumns(nodeLocation0);
      List<SelectItem> list0 = List.of(allColumns0, allColumns0, allColumns0, allColumns0, allColumns0, allColumns0, allColumns0);
      Select select0 = new Select(nodeLocation0, true, list0);
      String string0 = SqlFormatter.formatSql(select0, optional1);
      assertEquals("SELECT DISTINCT\n  *\n, *\n, *\n, *\n, *\n, *\n, *\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull41()  throws Throwable  {
      Identifier identifier0 = new Identifier("@r#EED");
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      TreeSet<Identifier> treeSet0 = new TreeSet<Identifier>();
      TreeSet<Identifier> treeSet1 = new TreeSet<Identifier>((SortedSet<Identifier>) treeSet0);
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(treeSet1, linkedHashSet0, false, optional0);
      NodeLocation nodeLocation0 = new NodeLocation(4057, 1390);
      TimeLiteral timeLiteral0 = new TimeLiteral(nodeLocation0, " WITH GRANT OPTION");
      TimeLiteral timeLiteral1 = new TimeLiteral("");
      Optional<NodeLocation> optional1 = timeLiteral1.getLocation();
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      ImmutableList<Expression> immutableList1 = ImmutableList.of(timeLiteral0, identifier0, timeLiteral1, timeLiteral0);
      MergeInsert mergeInsert0 = new MergeInsert(optional1, immutableList0, immutableList1);
      ImmutableList<Expression> immutableList2 = ImmutableList.of();
      Optional<List<Expression>> optional2 = Optional.of(immutableList2);
      SingleColumn singleColumn0 = new SingleColumn(identifier0);
      Optional<Identifier> optional3 = Optional.empty();
      SingleColumn singleColumn1 = new SingleColumn(nodeLocation0, identifier0, optional3);
      ImmutableList<SelectItem> immutableList3 = ImmutableList.of(singleColumn0, singleColumn1, singleColumn1, singleColumn1, singleColumn1, singleColumn0, singleColumn0, singleColumn0);
      Select select0 = new Select(nodeLocation0, false, immutableList3);
      SqlFormatter.formatSql(select0, optional2);
      String string0 = SqlFormatter.formatSql(singleColumn0, optional2);
      assertEquals("\"@r#EED\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull38()  throws Throwable  {
      Random.setNextRandom(1846);
      Random.setNextRandom(1846);
      System.setCurrentTimeMillis(1846);
      System.setCurrentTimeMillis(1846);
      Random.setNextRandom(813);
      Random.setNextRandom(1846);
      System.setCurrentTimeMillis(16L);
      String[] stringArray0 = new String[9];
      stringArray0[0] = "TABLE(";
      stringArray0[1] = "TABLE(";
      stringArray0[2] = "TABLE(";
      stringArray0[3] = "TABLE(";
      stringArray0[4] = "";
      stringArray0[5] = "";
      stringArray0[6] = "";
      stringArray0[7] = "";
      stringArray0[8] = "TABLE(";
      QualifiedName qualifiedName0 = QualifiedName.of("Zone file should not contain a mapping for key 0", stringArray0);
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      qualifiedName0.toString();
      CreateSchema createSchema0 = new CreateSchema(qualifiedName0, true, linkedList0);
      Optional.empty();
      SqlFormatter.formatSql(createSchema0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis(16L);
      System.setCurrentTimeMillis((-1100L));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull38()  throws Throwable  {
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.ofNullable(grantorSpecification0);
      QualifiedName qualifiedName0 = QualifiedName.of(" RECURSIVE");
      RenameTable renameTable0 = new RenameTable(qualifiedName0, qualifiedName0, true);
      int int0 = (-1734);
      NodeLocation nodeLocation0 = new NodeLocation((-1734), (-1734));
      RenameTable renameTable1 = new RenameTable(nodeLocation0, qualifiedName0, qualifiedName0, true);
      renameTable1.getChildren();
      qualifiedName0.getPrefix();
      Optional<List<Expression>> optional0 = Optional.empty();
      SqlFormatter.formatSql(renameTable0, optional0);
      Optional.ofNullable(null);
      // Undeclared exception!
      try { 
        Converter.from(null, null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull39()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("ROLES");
      RenameTable renameTable0 = new RenameTable(qualifiedName0, qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(renameTable0, optional0);
      assertEquals("ALTER TABLE IF EXISTS roles RENAME TO roles", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull40()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      Random.setNextRandom((-2060));
      System.setCurrentTimeMillis(0L);
      Random.setNextRandom(852);
      Random.setNextRandom(852);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      Random.setNextRandom((-2060));
      Random.setNextRandom(1232);
      System.setCurrentTimeMillis(725270293939359937L);
      String[] stringArray0 = new String[9];
      stringArray0[0] = "TABLE(";
      stringArray0[1] = "";
      stringArray0[2] = "TABLE(";
      stringArray0[3] = "TABLE(";
      stringArray0[4] = "TABLE(";
      stringArray0[5] = "TABLE(";
      stringArray0[6] = "TABLE(";
      stringArray0[7] = "TABLE(";
      stringArray0[8] = "TABLE(";
      QualifiedName qualifiedName0 = QualifiedName.of("TABLE(", stringArray0);
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      CreateSchema createSchema0 = new CreateSchema(qualifiedName0, false, linkedList0);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(createSchema0, optional0);
      assertEquals("CREATE SCHEMA \"TABLE(\".\"TABLE(\".\"\".\"TABLE(\".\"TABLE(\".\"TABLE(\".\"TABLE(\".\"TABLE(\".\"TABLE(\".\"TABLE(\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull39()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation((-993), (-993));
      QualifiedName qualifiedName0 = QualifiedName.of("-I[A/=j/)4");
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      qualifiedName0.getPrefix();
      CreateSchema createSchema0 = new CreateSchema(qualifiedName0, false, linkedList0);
      String string0 = SqlFormatter.formatSql(createSchema0, (Optional<List<Expression>>) null);
      assertEquals("CREATE SCHEMA \"-I[A/=j/)4\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull40()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      QualifiedName qualifiedName0 = QualifiedName.of("-I[A/=j/)4");
      LinkedList<Property> linkedList0 = new LinkedList<Property>();
      qualifiedName0.getPrefix();
      CreateSchema createSchema0 = new CreateSchema(qualifiedName0, true, linkedList0);
      String string0 = SqlFormatter.formatSql(createSchema0, (Optional<List<Expression>>) null);
      assertEquals("CREATE SCHEMA IF NOT EXISTS \"-I[A/=j/)4\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull41()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      NodeLocation nodeLocation0 = new NodeLocation(3, 2808);
      Optional<QualifiedName> optional0 = Optional.ofNullable(null);
      ShowGrants showGrants0 = new ShowGrants(nodeLocation0, false, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(showGrants0, optional1);
      assertEquals("SHOW GRANTS ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull42()  throws Throwable  {
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Optional<QualifiedName> optional1 = Optional.empty();
      ShowGrants showGrants0 = new ShowGrants(true, optional1);
      String string0 = SqlFormatter.formatSql(showGrants0, optional0);
      assertEquals("SHOW GRANTS ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull41()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("jhW");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.GRAPHVIZ;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation(51, 51);
      RenameTable renameTable0 = new RenameTable(nodeLocation0, qualifiedName0, qualifiedName0, false);
      SqlFormatter.formatSql(renameTable0, (Optional<List<Expression>>) null);
      Random.setNextRandom(51);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull35()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      Random.setNextRandom((-1563));
      QualifiedName qualifiedName0 = QualifiedName.of(" WITH ADMIN ");
      RenameTable renameTable0 = new RenameTable(qualifiedName0, qualifiedName0, false);
      renameTable0.getChildren();
      qualifiedName0.getPrefix();
      SqlFormatter.formatSql(renameTable0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(renameTable0, (Optional<List<Expression>>) null);
      Optional<List<Expression>> optional0 = Optional.ofNullable(null);
      SqlFormatter.formatSql(renameTable0, optional0);
      Function<Object, NodeLocation> function0 = (Function<Object, NodeLocation>) mock(Function.class, new ViolatedAssumptionAnswer());
      Converter<Object, NodeLocation> converter0 = Converter.from(function0, function0);
      Converter<NodeLocation, NodeLocation> converter1 = Converter.identity();
      java.util.function.Function.identity();
      Converter<NodeLocation, NodeLocation> converter2 = converter1.reverse();
      Converter<Object, NodeLocation> converter3 = converter0.andThen(converter2);
      optional0.map(converter3);
      NodeLocation nodeLocation0 = new NodeLocation((-1563), (-1349));
      Optional.ofNullable(nodeLocation0);
      System.setCurrentTimeMillis((-1563));
      SqlFormatter.formatSql(renameTable0, optional0);
      Random.setNextRandom((-1563));
      SqlFormatter.formatSql(renameTable0, optional0);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNoSuchElementExceptionAndFormatSqlWithNonNull()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedList<SelectItem> linkedList0 = new LinkedList<SelectItem>();
      Select select0 = new Select(false, linkedList0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(select0, optional0);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.MoreCollectors$ToOptionalState", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull42()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(null);
      Identifier identifier0 = new Identifier("EXTRACT(");
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.add(principalSpecification0);
      TreeSet<Identifier> treeSet0 = new TreeSet<Identifier>();
      TreeSet<Identifier> treeSet1 = new TreeSet<Identifier>();
      TreeSet<Identifier> treeSet2 = new TreeSet<Identifier>((SortedSet<Identifier>) treeSet1);
      GrantRoles grantRoles0 = new GrantRoles(treeSet0, linkedHashSet0, false, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      optional1.stream();
      ExternalBodyReference externalBodyReference1 = new ExternalBodyReference(identifier0);
      String string0 = SqlFormatter.formatSql(externalBodyReference1, optional1);
      assertEquals("EXTERNAL NAME \"EXTRACT(\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull36()  throws Throwable  {
      Identifier identifier0 = new Identifier("\"N$$m|-|>n)", true);
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference(identifier0);
      String string0 = SqlFormatter.formatSql(externalBodyReference0, (Optional<List<Expression>>) null);
      assertEquals("EXTERNAL NAME \"\"\"N$$m|-|>n)\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNoSuchElementException1()  throws Throwable  {
      QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation((-1983), (-1983));
      Stack<SelectItem> stack0 = new Stack<SelectItem>();
      Select select0 = new Select(nodeLocation0, false, stack0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(select0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.MoreCollectors$ToOptionalState", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNoSuchElementException2()  throws Throwable  {
      LinkedList<SelectItem> linkedList0 = new LinkedList<SelectItem>();
      Select select0 = new Select(true, linkedList0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(select0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.MoreCollectors$ToOptionalState", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNoSuchElementException3()  throws Throwable  {
      String string0 = "";
      QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(3, 3);
      LinkedList<SelectItem> linkedList0 = new LinkedList<SelectItem>();
      Select select0 = new Select(nodeLocation0, true, linkedList0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(select0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NoSuchElementException");
      
      } catch(NoSuchElementException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("com.google.common.collect.MoreCollectors$ToOptionalState", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull43()  throws Throwable  {
      QualifiedName.of("");
      Random.setNextRandom((-2402));
      Optional<List<Expression>> optional0 = Optional.empty();
      TransactionAccessMode transactionAccessMode0 = new TransactionAccessMode(true);
      String string0 = SqlFormatter.formatSql(transactionAccessMode0, optional0);
      assertEquals("READ ONLY", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull42()  throws Throwable  {
      TransactionAccessMode transactionAccessMode0 = new TransactionAccessMode(true);
      String string0 = SqlFormatter.formatSql(transactionAccessMode0, (Optional<List<Expression>>) null);
      assertEquals("READ ONLY", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull43()  throws Throwable  {
      TransactionAccessMode transactionAccessMode0 = new TransactionAccessMode(false);
      String string0 = SqlFormatter.formatSql(transactionAccessMode0, (Optional<List<Expression>>) null);
      assertEquals("READ WRITE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull44()  throws Throwable  {
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(0L);
      System.setCurrentTimeMillis(40320L);
      NodeLocation nodeLocation0 = new NodeLocation(2701, 1511);
      TransactionAccessMode transactionAccessMode0 = new TransactionAccessMode(nodeLocation0, false);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(transactionAccessMode0, optional0);
      assertEquals("READ WRITE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull44()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2, (-6));
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, treeSet0, false, optional0);
      NodeLocation nodeLocation1 = new NodeLocation((-2326), (-170));
      Rollback rollback0 = new Rollback(nodeLocation1);
      SqlFormatter.formatSql(rollback0, (Optional<List<Expression>>) null);
      Random.setNextRandom(2147483645);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull45()  throws Throwable  {
      QualifiedName.of("~dxP&2m");
      Rollback rollback0 = new Rollback();
      String string0 = SqlFormatter.formatSql(rollback0, (Optional<List<Expression>>) null);
      assertEquals("ROLLBACK", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull43()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      Optional<List<Expression>> optional0 = Optional.empty();
      Return return0 = new Return(currentUser0);
      String string0 = SqlFormatter.formatSql(return0, optional0);
      assertEquals("RETURN CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull44()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      String[] stringArray0 = new String[7];
      stringArray0[0] = "";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "";
      stringArray0[4] = "";
      stringArray0[5] = "";
      stringArray0[6] = "";
      QualifiedName qualifiedName0 = QualifiedName.of("", stringArray0);
      Optional<QualifiedName> optional0 = qualifiedName0.getPrefix();
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      ShowGrants showGrants0 = new ShowGrants(false, optional0);
      Optional<NodeLocation> optional1 = Optional.empty();
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      ImmutableList<Expression> immutableList1 = ImmutableList.of(identifier0, identifier0, currentUser0, identifier0);
      MergeInsert mergeInsert0 = new MergeInsert(optional1, immutableList0, immutableList1);
      mergeInsert0.getValues();
      Optional<List<Expression>> optional2 = Optional.ofNullable(immutableList1);
      SqlFormatter.formatSql(currentUser0, optional2);
      SqlFormatter.formatSql(mergeInsert0, optional2);
      Return return0 = new Return(currentUser0);
      Supplier<Optional<List<Expression>>> supplier0 = (Supplier<Optional<List<Expression>>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      Optional<List<Expression>> optional3 = optional2.or(supplier0);
      String string0 = SqlFormatter.formatSql(return0, optional3);
      assertEquals("RETURN CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull45()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      System.setCurrentTimeMillis(0L);
      QualifiedName qualifiedName0 = QualifiedName.of("DROP MATERIALIZED VIEW ");
      DropConstraint dropConstraint0 = new DropConstraint(qualifiedName0, "0vUu1 ^af>h", false, false);
      String string0 = SqlFormatter.formatSql(dropConstraint0, optional0);
      assertEquals("ALTER TABLE \"DROP MATERIALIZED VIEW \" DROP CONSTRAINT 0vUu1 ^af>h", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull46()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("')OiS?lgcCrHaG?0G");
      DropConstraint dropConstraint0 = new DropConstraint(qualifiedName0, "')OiS?lgcCrHaG?0G", false, false);
      String string0 = SqlFormatter.formatSql(dropConstraint0, optional0);
      assertEquals("ALTER TABLE \"')OiS?lgcCrHaG?0G\" DROP CONSTRAINT ')OiS?lgcCrHaG?0G", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull45()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      String[] stringArray0 = new String[4];
      stringArray0[0] = "";
      stringArray0[1] = "FRAsqRpq'2M:;VS[8";
      stringArray0[2] = "FRAsqRpq'2M:;VS[8";
      stringArray0[3] = "FRAsqRpq'2M:;VS[8";
      QualifiedName qualifiedName0 = QualifiedName.of("FRAsqRpq'2M:;VS[8", stringArray0);
      Optional<QualifiedName> optional0 = qualifiedName0.getPrefix();
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      ShowGrants showGrants0 = new ShowGrants(true, optional0);
      Optional.empty();
      ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      ImmutableList<Expression> immutableList1 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0);
      FunctionCall functionCall0 = new FunctionCall(qualifiedName0, immutableList1);
      Rollup rollup0 = new Rollup(immutableList0);
      List<Expression> list0 = rollup0.getExpressions();
      Execute execute0 = new Execute(identifier0, list0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(execute0, optional1);
      assertEquals("EXECUTE \"FRAsqRpq'2M:;VS[8\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull37()  throws Throwable  {
      QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(958, 958);
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier(optional0, "");
      Vector<Expression> vector0 = new Vector<Expression>();
      Execute execute0 = new Execute(nodeLocation0, identifier0, vector0);
      String string0 = SqlFormatter.formatSql(execute0, (Optional<List<Expression>>) null);
      assertEquals("EXECUTE \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull46()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("'IO'");
      ResetSession resetSession0 = new ResetSession(qualifiedName0);
      String string0 = SqlFormatter.formatSql(resetSession0, optional0);
      assertEquals("RESET SESSION 'io'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNullAndFormatSqlWithNonNullAndFormatSqlWithNonNull2()  throws Throwable  {
      System.setCurrentTimeMillis(38L);
      Random.setNextRandom(1);
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      String string0 = SqlFormatter.formatSql(externalBodyReference0, (Optional<List<Expression>>) null);
      externalBodyReference0.toString();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      QualifiedName qualifiedName0 = QualifiedName.of("EXTERNAL");
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.add(principalSpecification0);
      TreeSet<Identifier> treeSet0 = new TreeSet<Identifier>();
      TreeSet<Identifier> treeSet1 = new TreeSet<Identifier>((SortedSet<Identifier>) treeSet0);
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.of(grantorSpecification0);
      Optional<List<Expression>> optional0 = Optional.empty();
      optional0.stream();
      NodeLocation nodeLocation0 = new NodeLocation(1, 2328);
      ResetSession resetSession0 = new ResetSession(nodeLocation0, qualifiedName0);
      String string1 = SqlFormatter.formatSql(resetSession0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull47()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      System.setCurrentTimeMillis(0L);
      QualifiedName qualifiedName0 = QualifiedName.of("DROP MATERIALIZED VIEW ");
      DropConstraint dropConstraint0 = new DropConstraint(qualifiedName0, ":Z<-ycMSrf~#G3W4%9X", true, true);
      String string0 = SqlFormatter.formatSql(dropConstraint0, optional0);
      assertEquals("ALTER TABLE IF EXISTS \"DROP MATERIALIZED VIEW \" DROP CONSTRAINT IF EXISTS :Z<-ycMSrf~#G3W4%9X", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull48()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("')OiS?lgcCrHaG?0G");
      DropConstraint dropConstraint0 = new DropConstraint(qualifiedName0, "')OiS?lgcCrHaG?0G", true, false);
      SqlFormatter.formatSql(dropConstraint0, optional0);
      String string0 = SqlFormatter.formatSql(dropConstraint0, optional0);
      assertEquals("ALTER TABLE IF EXISTS \"')OiS?lgcCrHaG?0G\" DROP CONSTRAINT ')OiS?lgcCrHaG?0G", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull38()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      String string0 = SqlFormatter.formatSql(currentUser0, (Optional<List<Expression>>) null);
      assertEquals("CURRENT_USER", string0);
      
      ImmutableList<Expression> immutableList0 = ImmutableList.of(currentUser0, currentUser0);
      Values values0 = new Values(immutableList0);
      SqlFormatter.formatSql(values0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(currentUser0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull39()  throws Throwable  {
      System.setCurrentTimeMillis(1L);
      Random.setNextRandom(1);
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      Optional<List<Expression>> optional0 = null;
      SqlFormatter.formatSql(externalBodyReference0, (Optional<List<Expression>>) null);
      externalBodyReference0.toString();
      externalBodyReference0.getChildren();
      externalBodyReference0.toString();
      System.setCurrentTimeMillis(28178L);
      Object object0 = new Object();
      externalBodyReference0.getChildren();
      externalBodyReference0.equals(object0);
      // Undeclared exception!
      try { 
        externalBodyReference0.getArgumentTypeString();
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Unexpected table function argument type: ExternalBodyReference
         //
         verifyException("com.facebook.presto.sql.tree.Node", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull47()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      ImmutableList<Identifier> immutableList0 = ImmutableList.of();
      ImmutableList<Expression> immutableList1 = ImmutableList.copyOf(immutableList0);
      MergeInsert mergeInsert0 = new MergeInsert(immutableList0, immutableList1);
      String string0 = SqlFormatter.formatSql(mergeInsert0, optional0);
      assertEquals("WHEN NOT MATCHED THEN\n   INSERT \n   VALUES ()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull48()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("");
      Object object0 = new Object();
      identifier0.equals(object0);
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      MergeInsert mergeInsert0 = new MergeInsert(list0, immutableList0);
      String string0 = SqlFormatter.formatSql(mergeInsert0, optional0);
      String string1 = SqlFormatter.formatSql(mergeInsert0, optional0);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull49()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      Optional.ofNullable(grantorSpecification0);
      Identifier identifier0 = new Identifier("YEi#zh.j=gA5bibC$\"/");
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "YEi#zh.j=gA5bibC$\"/";
      stringArray0[1] = "YEi#zh.j=gA5bibC$\"/";
      stringArray0[2] = "YEi#zh.j=gA5bibC$\"/";
      stringArray0[3] = "";
      stringArray0[4] = "YEi#zh.j=gA5bibC$\"/";
      stringArray0[5] = "YEi#zh.j=gA5bibC$\"/";
      QualifiedName qualifiedName0 = QualifiedName.of("YEi#zh.j=gA5bibC$\"/", stringArray0);
      Optional<QualifiedName> optional0 = Optional.of(qualifiedName0);
      Identifier identifier1 = qualifiedName0.getOriginalSuffix();
      ShowGrants showGrants0 = new ShowGrants(false, optional0);
      Optional<NodeLocation> optional1 = Optional.empty();
      ImmutableList<Identifier> immutableList0 = ImmutableList.of(identifier0, identifier1, identifier1, identifier1, identifier1, identifier1, identifier0, identifier1);
      ImmutableList<Expression> immutableList1 = ImmutableList.of(identifier0, identifier1, identifier0, identifier1);
      MergeInsert mergeInsert0 = new MergeInsert(optional1, immutableList0, immutableList1);
      List<Expression> list0 = mergeInsert0.getValues();
      Optional<List<Expression>> optional2 = Optional.ofNullable(list0);
      String string0 = SqlFormatter.formatSql(showGrants0, optional2);
      SqlFormatter.formatSql(mergeInsert0, optional2);
      BooleanLiteral booleanLiteral0 = BooleanLiteral.FALSE_LITERAL;
      String string1 = SqlFormatter.formatSql(identifier1, optional2);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNonNull3()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.EQUAL;
      TableVersionExpression.versionExpression(tableVersionExpression_TableVersionOperator0, (Expression) currentUser0);
      NodeLocation nodeLocation0 = new NodeLocation(1, 0);
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier(optional0, "5\"Lv`'.M");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional1 = Optional.of(grantorSpecification0);
      RevokeRoles revokeRoles0 = new RevokeRoles(nodeLocation0, hashSet0, linkedHashSet0, false, optional1);
      Optional<GrantorSpecification> optional2 = revokeRoles0.getGrantor();
      CreateRole createRole0 = new CreateRole(nodeLocation0, identifier0, optional2);
      Optional<GrantorSpecification> optional3 = createRole0.getGrantor();
      CreateRole createRole1 = new CreateRole(nodeLocation0, identifier0, optional3);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      createRole0.getUpdateInfo();
      Optional<List<Expression>> optional4 = Optional.of(immutableList0);
      NullLiteral nullLiteral0 = new NullLiteral();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(createRole1, optional4);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull40()  throws Throwable  {
      QualifiedName.of("ROW(");
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.JSON;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation((-3238), (-3238));
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      Optional<NodeLocation> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier(optional0, "4q%W[");
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional1 = Optional.ofNullable(grantorSpecification0);
      CreateRole createRole0 = new CreateRole(identifier0, optional1);
      createRole0.getGrantor();
      String string0 = SqlFormatter.formatSql(createRole0, (Optional<List<Expression>>) null);
      assertEquals("CREATE ROLE \"4q%W[\" WITH ADMIN CURRENT_ROLE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull50()  throws Throwable  {
      System.setCurrentTimeMillis(946L);
      System.setCurrentTimeMillis((-71L));
      NodeLocation nodeLocation0 = new NodeLocation(2, (-707));
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, ">%lsF");
      String[] stringArray0 = new String[4];
      stringArray0[0] = ">%lsF";
      stringArray0[1] = ">%lsF";
      stringArray0[2] = ">%lsF";
      stringArray0[3] = ">%lsF";
      QualifiedName qualifiedName0 = QualifiedName.of(">%lsF", stringArray0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Rollup rollup0 = new Rollup(immutableList0);
      List<Expression> list0 = rollup0.getExpressions();
      FunctionCall functionCall0 = new FunctionCall(qualifiedName0, list0);
      List<Expression> list1 = functionCall0.getArguments();
      Execute execute0 = new Execute(identifier0, list1);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(execute0, optional1);
      assertNotNull(string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull51()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(1264, 1264);
      Identifier identifier0 = new Identifier("lr)u^>1?%<!9^,kJZR");
      String string0 = identifier0.getCanonicalValue();
      InPredicate inPredicate0 = new InPredicate(nodeLocation0, identifier0, identifier0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, inPredicate0);
      Execute execute0 = new Execute(nodeLocation0, identifier0, immutableList0);
      String string1 = SqlFormatter.formatSql(execute0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull46()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      String[] stringArray0 = new String[5];
      stringArray0[0] = "v'2ng@y*<";
      stringArray0[1] = "";
      stringArray0[2] = "";
      stringArray0[3] = "UPDATE ";
      stringArray0[4] = "gDEK(J{It%Ae";
      QualifiedName qualifiedName1 = QualifiedName.of("", stringArray0);
      Optional<QualifiedName> optional0 = Optional.of(qualifiedName1);
      qualifiedName0.getOriginalSuffix();
      ShowGrants showGrants0 = new ShowGrants(true, optional0);
      String string0 = SqlFormatter.formatSql(showGrants0, (Optional<List<Expression>>) null);
      assertEquals("SHOW GRANTS ON TABLE .v'2ng@y*<...update .gdek(j{it%ae", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull47()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("JX!F}nWV(Y+U");
      Stack<String> stack0 = new Stack<String>();
      NodeLocation nodeLocation0 = new NodeLocation(372, 372);
      Optional<QualifiedName> optional0 = Optional.of(qualifiedName0);
      ShowGrants showGrants0 = new ShowGrants(nodeLocation0, true, optional0);
      String string0 = SqlFormatter.formatSql(showGrants0, (Optional<List<Expression>>) null);
      assertEquals("SHOW GRANTS ON TABLE jx!f}nwv(y+u", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull41()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      NodeLocation nodeLocation1 = new NodeLocation(1538, 0);
      DereferenceExpression dereferenceExpression0 = new DereferenceExpression(nodeLocation0, identifier0, identifier0);
      QualifiedName qualifiedName0 = DereferenceExpression.getQualifiedName(dereferenceExpression0);
      TruncateTable truncateTable0 = new TruncateTable(nodeLocation1, qualifiedName0);
      String string0 = SqlFormatter.formatSql(truncateTable0, (Optional<List<Expression>>) null);
      assertEquals("TRUNCATE TABLE \"SHOW CATALOGS\".\"SHOW CATALOGS\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull5()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      TruncateTable truncateTable0 = new TruncateTable(nodeLocation0, (QualifiedName) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(truncateTable0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.QualifiedName.getOriginalParts()\" because \"name\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNull6()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-3775), (-383));
      TruncateTable truncateTable0 = new TruncateTable(nodeLocation0, (QualifiedName) null);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(truncateTable0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.QualifiedName.getOriginalParts()\" because \"name\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull52()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      TreeSet<Identifier> treeSet0 = new TreeSet<Identifier>();
      TreeSet<Identifier> treeSet1 = new TreeSet<Identifier>((SortedSet<Identifier>) treeSet0);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(treeSet1);
      Values values0 = new Values(immutableList0);
      values0.getRows();
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      String[] stringArray0 = new String[6];
      stringArray0[0] = "'xs[]Bxj:Toy.";
      stringArray0[1] = "'xs[]Bxj:Toy.";
      stringArray0[2] = "'xs[]Bxj:Toy.";
      stringArray0[3] = "'xs[]Bxj:Toy.";
      stringArray0[4] = "'xs[]Bxj:Toy.";
      stringArray0[5] = "'xs[]Bxj:Toy.";
      QualifiedName qualifiedName0 = QualifiedName.of("'xs[]Bxj:Toy.", stringArray0);
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.LESS_THAN;
      CurrentUser currentUser0 = new CurrentUser();
      TableVersionExpression tableVersionExpression0 = TableVersionExpression.versionExpression(nodeLocation0, tableVersionExpression_TableVersionOperator0, (Expression) currentUser0);
      Table table0 = new Table(nodeLocation0, qualifiedName0, tableVersionExpression0);
      String string0 = SqlFormatter.formatSql(table0, optional0);
      assertEquals("\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\".\"'xs[]Bxj:Toy.\" FOR VERSION BEFORE CURRENT_USER ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull53()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("_");
      QualifiedName qualifiedName0 = QualifiedName.of("_");
      NodeLocation nodeLocation0 = new NodeLocation((-1473), 180);
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.EQUAL;
      TableVersionExpression tableVersionExpression0 = TableVersionExpression.timestampExpression(tableVersionExpression_TableVersionOperator0, (Expression) identifier0);
      Table table0 = new Table(nodeLocation0, qualifiedName0, tableVersionExpression0);
      IfExpression ifExpression0 = new IfExpression(nodeLocation0, identifier0, tableVersionExpression0, identifier0);
      String string0 = SqlFormatter.formatSql(table0, optional0);
      assertEquals("_ FOR TIMESTAMP AS OF _ ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull48()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      LinkedList<WhenClause> linkedList0 = new LinkedList<WhenClause>();
      NodeLocation nodeLocation0 = new NodeLocation(3421, (-309));
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.TABLE;
      ShowCreate showCreate0 = new ShowCreate(nodeLocation0, showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull49()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of(" WITH GRANT OPTION");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.TABLE;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CREATE TABLE \" WITH GRANT OPTION\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull49()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      Optional<List<Expression>> optional0 = Optional.empty();
      String[] stringArray0 = new String[4];
      stringArray0[0] = "gDEK(J{It%Ae";
      stringArray0[1] = "UPDATE ";
      stringArray0[2] = "gDEK(J{It%Ae";
      stringArray0[3] = "gDEK(J{It%Ae";
      QualifiedName qualifiedName0 = QualifiedName.of("gDEK(J{It%Ae", stringArray0);
      Optional<QualifiedName> optional1 = Optional.of(qualifiedName0);
      qualifiedName0.getOriginalSuffix();
      ShowGrants showGrants0 = new ShowGrants(false, optional1);
      String string0 = SqlFormatter.formatSql(showGrants0, optional0);
      assertEquals("SHOW GRANTS ON gdek(j{it%ae.gdek(j{it%ae.update .gdek(j{it%ae.gdek(j{it%ae", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull50()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Optional<QualifiedName> optional0 = Optional.of(qualifiedName0);
      ShowGrants showGrants0 = new ShowGrants(false, optional0);
      String string0 = SqlFormatter.formatSql(showGrants0, (Optional<List<Expression>>) null);
      assertEquals("SHOW GRANTS ON ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull54()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), 1);
      Identifier identifier0 = new Identifier("OR REPLACE ");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, false, optional0);
      grantRoles0.getGrantor();
      NodeLocation nodeLocation1 = new NodeLocation(1, 1408);
      Identifier identifier1 = new Identifier("OVER", false);
      CreateRole createRole0 = new CreateRole(nodeLocation1, identifier1, optional0);
      createRole0.getUpdateInfo();
      NullIfExpression nullIfExpression0 = new NullIfExpression(identifier0, identifier0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier1, identifier1, identifier1, identifier1, identifier0, identifier0, identifier1, identifier1, nullIfExpression0, identifier0);
      Optional<List<Expression>> optional1 = Optional.of(immutableList0);
      NullLiteral nullLiteral0 = new NullLiteral();
      String string0 = SqlFormatter.formatSql(nullLiteral0, optional1);
      DropRole dropRole0 = new DropRole(identifier0);
      String string1 = SqlFormatter.formatSql(dropRole0, optional1);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull42()  throws Throwable  {
      QualifiedName.of("~");
      NodeLocation nodeLocation0 = new NodeLocation(32, 32);
      Identifier identifier0 = new Identifier("");
      DropRole dropRole0 = new DropRole(nodeLocation0, identifier0);
      String string0 = SqlFormatter.formatSql(dropRole0, (Optional<List<Expression>>) null);
      assertEquals("DROP ROLE \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull50()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, false, optional0);
      Optional<GrantorSpecification> optional1 = grantRoles0.getGrantor();
      CreateRole createRole0 = new CreateRole(nodeLocation0, identifier0, optional1);
      TreeSet<Identifier> treeSet1 = new TreeSet<Identifier>();
      RevokeRoles revokeRoles0 = new RevokeRoles(treeSet1, treeSet0, false, optional0);
      revokeRoles0.getGrantees();
      GrantRoles grantRoles1 = new GrantRoles(treeSet1, treeSet0, false, optional0);
      Optional<List<Expression>> optional2 = Optional.empty();
      SqlFormatter.formatSql(revokeRoles0, optional2);
      String string0 = SqlFormatter.formatSql(identifier0, optional2);
      assertEquals("\"SHOW CATALOGS\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull51()  throws Throwable  {
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(null);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      RevokeRoles revokeRoles0 = new RevokeRoles(linkedHashSet0, treeSet0, false, optional0);
      revokeRoles0.getGrantees();
      String string0 = SqlFormatter.formatSql(revokeRoles0, (Optional<List<Expression>>) null);
      assertEquals("REVOKE  FROM ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull43()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      NodeLocation nodeLocation0 = new NodeLocation(41, 41);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, true);
      NullLiteral nullLiteral0 = new NullLiteral();
      NullIfExpression nullIfExpression0 = new NullIfExpression(identifier0, nullLiteral0);
      Expression[] expressionArray0 = new Expression[7];
      expressionArray0[0] = (Expression) identifier0;
      expressionArray0[1] = (Expression) identifier0;
      BetweenPredicate betweenPredicate0 = new BetweenPredicate(expressionArray0[0], nullIfExpression0, identifier0);
      expressionArray0[2] = (Expression) betweenPredicate0;
      expressionArray0[3] = (Expression) nullIfExpression0;
      expressionArray0[4] = (Expression) nullIfExpression0;
      expressionArray0[5] = (Expression) nullLiteral0;
      expressionArray0[6] = (Expression) nullLiteral0;
      CoalesceExpression coalesceExpression0 = new CoalesceExpression(nullLiteral0, identifier0, expressionArray0);
      ImmutableList.of(nullLiteral0, nullIfExpression0, identifier0, coalesceExpression0, expressionArray0[6], expressionArray0[1], expressionArray0[1], nullIfExpression0, expressionArray0[1], expressionArray0[2], expressionArray0[4]);
      Optional<List<Expression>> optional0 = Optional.empty();
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.VIEW;
      ShowCreate showCreate0 = new ShowCreate(nodeLocation0, showCreate_Type0, qualifiedName0);
      SqlFormatter.formatSql(expressionArray0[6], (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(showCreate0, optional0);
      Random.setNextRandom((-560));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull52()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of(" WITH GRANT OPTION");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CREATE VIEW \" WITH GRANT OPTION\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull51()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "ROLES";
      QualifiedName qualifiedName0 = QualifiedName.of("ROLES", stringArray0);
      Identifier identifier0 = new Identifier("ROLES");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, true);
      NullIfExpression nullIfExpression0 = new NullIfExpression(identifier0, identifier0);
      ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, nullIfExpression0, nullIfExpression0, nullIfExpression0, identifier0);
      Optional<List<Expression>> optional0 = Optional.empty();
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(nodeLocation0, showCreate_Type0, qualifiedName0);
      SqlFormatter.formatSql(dropColumn0, optional0);
      SqlFormatter.formatSql(showCreate0, optional0);
      Random.setNextRandom(3278);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull52()  throws Throwable  {
      Offset offset0 = new Offset("z1Ey%R;/.<]@H&i");
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(offset0, optional0);
      assertEquals("OFFSET z1Ey%R;/.<]@H&i ROWS\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull44()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "ROLES";
      QualifiedName qualifiedName0 = QualifiedName.of("ROLES", stringArray0);
      Identifier identifier0 = new Identifier("ROLES");
      ShowColumns showColumns0 = new ShowColumns(nodeLocation0, qualifiedName0);
      SqlFormatter.formatSql(showColumns0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(showColumns0, (Optional<List<Expression>>) null);
      Offset offset0 = new Offset(nodeLocation0, "W ov3");
      SqlFormatter.formatSql(offset0, (Optional<List<Expression>>) null);
      LinkedList<WhenClause> linkedList0 = new LinkedList<WhenClause>();
      Optional.ofNullable(identifier0);
      Table table0 = new Table(qualifiedName0);
      String string0 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull45()  throws Throwable  {
      Random.setNextRandom(186);
      Random.setNextRandom(186);
      Random.setNextRandom(186);
      Random.setNextRandom(1319);
      Random.setNextRandom(186);
      Random.setNextRandom(1319);
      NodeLocation nodeLocation0 = new NodeLocation(186, 186);
      QualifiedName qualifiedName0 = QualifiedName.of("T,4y3T>");
      List<Identifier> list0 = qualifiedName0.getOriginalParts();
      LinkedList<Identifier> linkedList0 = new LinkedList<Identifier>(list0);
      QualifiedName qualifiedName1 = QualifiedName.of((Iterable<Identifier>) linkedList0);
      ShowColumns showColumns0 = new ShowColumns(nodeLocation0, qualifiedName1);
      String string0 = SqlFormatter.formatSql(showColumns0, (Optional<List<Expression>>) null);
      assertEquals("SHOW COLUMNS FROM \"T,4y3T>\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull55()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("6%i");
      Optional<QualifiedName> optional1 = Optional.empty();
      ShowGrants showGrants0 = new ShowGrants(true, optional1);
      Prepare prepare0 = new Prepare(identifier0, showGrants0);
      String string0 = SqlFormatter.formatSql(prepare0, optional0);
      assertEquals("PREPARE \"6%i\" FROM\nSHOW GRANTS ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull56()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.toArray();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(null);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, linkedHashSet0, true, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      Prepare prepare0 = new Prepare(nodeLocation0, identifier0, grantRoles0);
      String string0 = SqlFormatter.formatSql(prepare0, optional1);
      assertEquals("PREPARE \"SHOW CATALOGS\" FROM\nGRANT  TO  WITH ADMIN OPTION", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull53()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      qualifiedName0.getPrefix();
      DropTable dropTable0 = new DropTable(qualifiedName0, false);
      dropTable0.equals(qualifiedName0);
      SqlFormatter.formatSql(dropTable0, (Optional<List<Expression>>) null);
      Random.setNextRandom(220);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull53()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("");
      DropTable dropTable0 = new DropTable(qualifiedName0, false);
      String string0 = SqlFormatter.formatSql(dropTable0, optional0);
      assertEquals("DROP TABLE ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull54()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional.empty();
      Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      String[] stringArray0 = new String[3];
      stringArray0[0] = "SHOW CATALOGS";
      stringArray0[1] = "SHOW CATALOGS";
      stringArray0[2] = "WHEN MATCHED";
      QualifiedName qualifiedName0 = QualifiedName.of("WHEN MATCHED", stringArray0);
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      Optional<List<Expression>> optional0 = Optional.empty();
      ArrayList<Expression> arrayList0 = new ArrayList<Expression>();
      Row row0 = new Row(arrayList0);
      optional0.equals(qualifiedName0);
      SqlFormatter.formatSql(renameView0, optional0);
      SqlFormatter.formatSql(identifier0, optional0);
      Random.setNextRandom((-2989));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull54()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)ifJrY4[>q|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, false);
      String string0 = SqlFormatter.formatSql(renameView0, (Optional<List<Expression>>) null);
      assertEquals("ALTER VIEW \"Ax)ifJrY4[>q|\" RENAME TO \"Ax)ifJrY4[>q|\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull55()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("GRANT ");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional.empty();
      Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName.of("ISH=,6(pzma:iP");
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0);
      Row row0 = new Row(immutableList0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      optional0.equals(principalSpecification_Type0);
      SqlFormatter.formatSql(row0, optional0);
      String string0 = SqlFormatter.formatSql(identifier0, optional0);
      assertEquals("\"GRANT \"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull56()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Random.setNextRandom((-1729));
      Random.setNextRandom(2);
      Random.setNextRandom(1);
      Random.setNextRandom((-248));
      hashSet0.remove(immutableList0);
      Random.setNextRandom((-1776));
      String[] stringArray0 = new String[8];
      stringArray0[0] = "c";
      stringArray0[1] = "=w='[Q(";
      stringArray0[2] = "iWt&Ag";
      stringArray0[3] = "=w='[Q(";
      stringArray0[4] = "=w='[Q(";
      stringArray0[5] = "=w='[Q(";
      stringArray0[6] = "=w='[Q(";
      stringArray0[7] = "=w='[Q(";
      QualifiedName qualifiedName0 = QualifiedName.of("=w='[Q(", stringArray0);
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      Optional<List<Expression>> optional0 = Optional.empty();
      Row row0 = new Row(immutableList0);
      optional0.equals((Object) null);
      SqlFormatter.formatSql(row0, optional0);
      String string0 = SqlFormatter.formatSql(row0, optional0);
      assertEquals("ROW()", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull55()  throws Throwable  {
      Random.setNextRandom(40);
      Random.setNextRandom(2500);
      Random.setNextRandom((-232));
      System.setCurrentTimeMillis(40);
      Random.setNextRandom(40);
      NodeLocation nodeLocation0 = new NodeLocation((-232), 2500);
      CurrentTime.Function currentTime_Function0 = CurrentTime.Function.LOCALTIME;
      CurrentTime currentTime0 = new CurrentTime(nodeLocation0, currentTime_Function0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(currentTime0, currentTime0, currentTime0);
      Row row0 = new Row(nodeLocation0, immutableList0);
      String string0 = SqlFormatter.formatSql(row0, (Optional<List<Expression>>) null);
      assertEquals("ROW(localtime, localtime, localtime)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull57()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, false, optional0);
      grantRoles0.getGrantor();
      RevokeRoles revokeRoles0 = new RevokeRoles(hashSet0, treeSet0, true, optional0);
      revokeRoles0.getGrantees();
      GrantRoles grantRoles1 = new GrantRoles(hashSet0, treeSet0, false, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revokeRoles0, optional1);
      assertEquals("REVOKE ADMIN OPTION FOR  FROM ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull46()  throws Throwable  {
      AllColumns allColumns0 = new AllColumns();
      String string0 = SqlFormatter.formatSql(allColumns0, (Optional<List<Expression>>) null);
      assertEquals("*", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull47()  throws Throwable  {
      AllColumns allColumns0 = new AllColumns();
      allColumns0.toString();
      String string0 = SqlFormatter.formatSql(allColumns0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(allColumns0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(allColumns0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull48()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-1735), 1297);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      TableVersionExpression.TableVersionType tableVersionExpression_TableVersionType0 = TableVersionExpression.TableVersionType.VERSION;
      Optional.empty();
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator0 = TableVersionExpression.TableVersionOperator.EQUAL;
      SymbolReference symbolReference0 = new SymbolReference("2Jb-bA])w^~9vGS&");
      TableVersionExpression tableVersionExpression0 = new TableVersionExpression(nodeLocation0, tableVersionExpression_TableVersionType0, tableVersionExpression_TableVersionOperator0, symbolReference0);
      NodeLocation nodeLocation1 = new NodeLocation(3, 1297);
      TableVersionExpression.TableVersionOperator tableVersionExpression_TableVersionOperator1 = TableVersionExpression.TableVersionOperator.LESS_THAN;
      Cast cast0 = new Cast(tableVersionExpression0, "0:F&6F!F~BUGOf#");
      TableVersionExpression.versionExpression(nodeLocation1, tableVersionExpression_TableVersionOperator1, (Expression) cast0);
      Cast cast1 = new Cast(optional0, tableVersionExpression0, "INT", false, false);
      cast1.getChildren();
      CallArgument callArgument0 = new CallArgument(nodeLocation0, cast1);
      cast1.getChildren();
      SqlFormatter.formatSql(callArgument0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(symbolReference0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(symbolReference0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(callArgument0, (Optional<List<Expression>>) null);
      String string0 = SqlFormatter.formatSql(cast1, (Optional<List<Expression>>) null);
      assertEquals("CAST(FOR VERSION AS OF \"2Jb-bA])w^~9vGS&\"  AS int)", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull57()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2162, 2162);
      Optional.empty();
      Optional<List<Expression>> optional0 = Optional.empty();
      Identifier identifier0 = new Identifier("d");
      QualifiedName.of("d");
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "", identifier0);
      CallArgument callArgument1 = new CallArgument(nodeLocation0, identifier0);
      String string0 = SqlFormatter.formatSql(callArgument1, optional0);
      assertEquals("d", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull56()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)ifuY4>q|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(renameView0, (Optional<List<Expression>>) null);
      assertEquals("ALTER VIEW IF EXISTS \"Ax)ifuY4>q|\" RENAME TO \"Ax)ifuY4>q|\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull58()  throws Throwable  {
      Random.setNextRandom(3);
      Random.setNextRandom(3);
      Random.setNextRandom(707);
      Random.setNextRandom(1);
      Random.setNextRandom(3);
      Random.setNextRandom((-343));
      Random.setNextRandom(3);
      Random.setNextRandom(3);
      Random.setNextRandom(1);
      Random.setNextRandom((-343));
      Random.setNextRandom(0);
      Random.setNextRandom(707);
      String[] stringArray0 = new String[0];
      QualifiedName qualifiedName0 = QualifiedName.of("c", stringArray0);
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(renameView0, optional0);
      assertEquals("ALTER VIEW IF EXISTS c RENAME TO c", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull57()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("wgTWNX?jOtq6bE");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.SCHEMA;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CREATE SCHEMA \"wgTWNX?jOtq6bE\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull59()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, "gql9>G>]Zo");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, " BETWEEN ", false, false);
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Values values0 = new Values(immutableList0);
      List<Expression> list1 = values0.getRows();
      Optional<List<Expression>> optional1 = Optional.of(list1);
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "CALLED", identifier0);
      Optional.empty();
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.SCHEMA;
      ShowCreate showCreate0 = new ShowCreate(nodeLocation0, showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, optional1);
      assertEquals("SHOW CREATE SCHEMA \"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\".\"gql9>G>]Zo\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull58()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CREATE MATERIALIZED VIEW \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull5()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.toArray();
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((Optional) null).when(grantorSpecification0).getPrincipal();
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      RevokeRoles revokeRoles0 = new RevokeRoles(linkedHashSet1, linkedHashSet0, true, optional0);
      Set<PrincipalSpecification> set0 = revokeRoles0.getGrantees();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, set0, true, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(grantRoles0, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.Optional.get()\" because the return value of \"com.facebook.presto.sql.tree.GrantorSpecification.getPrincipal()\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull5()  throws Throwable  {
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.PRINCIPAL;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((Optional) null).when(grantorSpecification0).getPrincipal();
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      HashSet<PrincipalSpecification> hashSet0 = new LinkedHashSet<PrincipalSpecification>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, hashSet0, false, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"java.util.Optional.get()\" because the return value of \"com.facebook.presto.sql.tree.GrantorSpecification.getPrincipal()\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull49()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-142), (-142));
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet1.toArray();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      String[] stringArray0 = new String[7];
      stringArray0[0] = "z:4Zfg~Uzm";
      stringArray0[1] = "addDFAState ";
      stringArray0[2] = "z:4Zfg~Uzm";
      stringArray0[3] = "z:4Zfg~Uzm";
      stringArray0[4] = "z:4Zfg~Uzm";
      stringArray0[5] = "z:4Zfg~Uzm";
      stringArray0[6] = "z:4Zfg~Uzm";
      QualifiedName qualifiedName0 = QualifiedName.of("z:4Zfg~Uzm", stringArray0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      linkedHashSet1.addFirst(principalSpecification0);
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification.Type grantorSpecification_Type1 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0, grantorSpecification_Type1).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      optional0.ifPresent(consumer0);
      Set<Identifier> set0 = grantRoles0.getRoles();
      GrantRoles grantRoles1 = new GrantRoles(nodeLocation0, set0, linkedHashSet1, true, optional0);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional1 = Optional.ofNullable(immutableList0);
      SqlFormatter.formatSql(identifier0, optional1);
      String string0 = SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
      Table table0 = new Table(qualifiedName0);
      Optional.of(immutableList0);
      SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull60()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.toArray();
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      RevokeRoles revokeRoles0 = new RevokeRoles(linkedHashSet1, linkedHashSet0, true, optional0);
      Set<PrincipalSpecification> set0 = revokeRoles0.getGrantees();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, set0, true, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(revokeRoles0, optional1);
      assertEquals("REVOKE ADMIN OPTION FOR  FROM  GRANTED BY CURRENT_ROLE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull50()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      currentUser0.getChildren();
      SqlFormatter.formatSql(currentUser0, (Optional<List<Expression>>) null);
      NodeLocation nodeLocation0 = new NodeLocation(9, 32);
      QualifiedName qualifiedName0 = QualifiedName.of("CURRENT_USER");
      SetSession setSession0 = new SetSession(nodeLocation0, qualifiedName0, currentUser0);
      String string0 = SqlFormatter.formatSql(setSession0, (Optional<List<Expression>>) null);
      assertEquals("SET SESSION current_user = CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull58()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(4783, 3);
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      String string0 = identifier0.getCanonicalValue();
      LambdaArgumentDeclaration lambdaArgumentDeclaration0 = new LambdaArgumentDeclaration((Identifier) null);
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "SHOW CATALOGS", identifier0);
      Optional<List<Expression>> optional0 = Optional.empty();
      SetSession setSession0 = new SetSession(nodeLocation0, (QualifiedName) null, identifier0);
      String string1 = SqlFormatter.formatSql(setSession0, optional0);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull51()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, "gql9>G>]Zo");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, " BETWEEN ", false, false);
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Vector<WhenClause> vector0 = new Vector<WhenClause>();
      FunctionCall functionCall0 = new FunctionCall(nodeLocation0, qualifiedName0, immutableList0);
      Optional<Expression> optional1 = functionCall0.getFilter();
      SearchedCaseExpression searchedCaseExpression0 = new SearchedCaseExpression(nodeLocation0, vector0, optional1);
      searchedCaseExpression0.getDefaultValue();
      String string0 = SqlFormatter.formatSql(dropBranch0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      QualifiedName qualifiedName1 = QualifiedName.of("\"gql9>G>]Zo\"");
      Table table0 = new Table(qualifiedName1);
      RefreshMaterializedView refreshMaterializedView0 = new RefreshMaterializedView(nodeLocation0, table0, optional1);
      SqlFormatter.formatSql(dropBranch0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(refreshMaterializedView0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull52()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(57, 8);
      QualifiedName qualifiedName0 = QualifiedName.of("");
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Optional<Expression> optional0 = Optional.empty();
      qualifiedName0.getPrefix();
      RefreshMaterializedView refreshMaterializedView0 = new RefreshMaterializedView(nodeLocation0, table0, optional0);
      Optional<Expression> optional1 = refreshMaterializedView0.getWhere();
      RefreshMaterializedView refreshMaterializedView1 = new RefreshMaterializedView(table0, optional1);
      String string0 = SqlFormatter.formatSql(refreshMaterializedView1, (Optional<List<Expression>>) null);
      assertEquals("REFRESH MATERIALIZED VIEW \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull59()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier1, identifier1);
      Optional<List<String>> optional1 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      Grant grant0 = new Grant(optional1, false, qualifiedName0, principalSpecification0, true);
      SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      Random.setNextRandom(3);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull61()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("DAY_OF_YEAR", false);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "DAY_OF_YEAR");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier1, identifier1);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, "w]-", false, false);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(list0);
      Optional<List<Expression>> optional1 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(dropBranch0, optional1);
      assertEquals("ALTER TABLE DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR.DAY_OF_YEAR DROP BRANCH 'w]-'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull60()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("AfF");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      String string0 = SqlFormatter.formatSql(showCreate0, (Optional<List<Expression>>) null);
      assertEquals("SHOW CREATE MATERIALIZED VIEW AfF", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull6()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet0.toArray();
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      RevokeRoles revokeRoles0 = new RevokeRoles(linkedHashSet1, linkedHashSet0, true, optional0);
      Set<PrincipalSpecification> set0 = revokeRoles0.getGrantees();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, set0, true, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(revokeRoles0, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull6()  throws Throwable  {
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      RevokeRoles revokeRoles0 = new RevokeRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      Set<PrincipalSpecification> set0 = revokeRoles0.getGrantees();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, set0, true, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(revokeRoles0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull62()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      RevokeRoles revokeRoles0 = new RevokeRoles(hashSet0, linkedHashSet0, true, optional0);
      ArrayList<Expression> arrayList0 = new ArrayList<Expression>();
      Optional<List<Expression>> optional1 = Optional.of(arrayList0);
      String string0 = SqlFormatter.formatSql(revokeRoles0, optional1);
      assertEquals("REVOKE ADMIN OPTION FOR  FROM ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull59()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      NodeLocation nodeLocation0 = new NodeLocation(2, (-6));
      Identifier identifier0 = new Identifier(nodeLocation0, "'ON'", true);
      hashSet0.add(identifier0);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Values values0 = new Values(immutableList0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(values0, optional0);
      assertEquals(" VALUES \n  \"'ON'\"\n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull60()  throws Throwable  {
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Values values0 = new Values(immutableList0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(values0, optional0);
      assertEquals(" VALUES \n", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull61()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier0 = new Identifier(optional0, "gql9>G>]Zo");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, " BETWEEN ", false, false);
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>(2);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      Values values0 = new Values(immutableList0);
      List<Expression> list1 = values0.getRows();
      Optional<List<Expression>> optional1 = Optional.of(list1);
      String string0 = SqlFormatter.formatSql(dropBranch0, optional1);
      String string1 = SqlFormatter.formatSql(values0, optional1);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull63()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("ROW");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.GRAPHVIZ;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      Optional<List<Expression>> optional0 = Optional.empty();
      DropTable dropTable0 = new DropTable(qualifiedName0, true);
      String string0 = SqlFormatter.formatSql(dropTable0, optional0);
      assertEquals("DROP TABLE IF EXISTS row", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull61()  throws Throwable  {
      String[] stringArray0 = new String[6];
      stringArray0[0] = "(L";
      stringArray0[1] = "(L";
      stringArray0[2] = "(L";
      stringArray0[3] = "(L";
      stringArray0[4] = "(L";
      stringArray0[5] = "(L";
      QualifiedName qualifiedName0 = QualifiedName.of("(L", stringArray0);
      qualifiedName0.getPrefix();
      DropTable dropTable0 = new DropTable(qualifiedName0, true);
      dropTable0.equals((Object) null);
      String string0 = SqlFormatter.formatSql(dropTable0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTable0, (Optional<List<Expression>>) null);
      Random.setNextRandom(3);
      String string1 = SqlFormatter.formatSql(dropTable0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull64()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      String[] stringArray0 = new String[2];
      stringArray0[0] = "Cu,zf";
      stringArray0[1] = "Cu,zf";
      QualifiedName qualifiedName0 = QualifiedName.of("visitExpression should only be called at root", stringArray0);
      Identifier identifier0 = new Identifier("");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, false);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(dropColumn0, optional0);
      assertEquals("ALTER TABLE IF EXISTS \"visitExpression should only be called at root\".\"Cu,zf\".\"Cu,zf\" DROP COLUMN \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull62()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(4783, 3);
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      String string0 = identifier0.getCanonicalValue();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, true, optional0);
      grantRoles0.getGrantor();
      CreateRole createRole0 = new CreateRole(nodeLocation0, identifier0, optional0);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      List.of(identifier0, identifier0, identifier0, identifier0, identifier0);
      createRole0.getUpdateInfo();
      grantRoles0.toString();
      grantRoles0.getUpdateInfo();
      Optional<List<Expression>> optional1 = Optional.of(immutableList0);
      SqlFormatter.formatSql(identifier0, optional1);
      SqlFormatter.formatSql(createRole0, optional1);
      NodeLocation nodeLocation1 = new NodeLocation((-431), 4783);
      CallArgument callArgument0 = new CallArgument(nodeLocation1, "}4s#*Bxsx~Vz", identifier0);
      Optional<List<Expression>> optional2 = Optional.empty();
      String string1 = SqlFormatter.formatSql(callArgument0, optional2);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull65()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      Identifier identifier2 = new Identifier("Cu,zf");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier2, identifier2);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(qualifiedName0, "w]-", true, true);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(list0);
      Optional<List<Expression>> optional1 = Optional.ofNullable(immutableList0);
      SqlFormatter.formatSql(identifier1, optional1);
      SqlFormatter.formatSql(dropBranch0, optional1);
      NodeLocation nodeLocation1 = new NodeLocation(3493, 412);
      optional0.get();
      ImmutableList<String> immutableList1 = ImmutableList.of("7m}J2", "Cu,zf", "ALTER TABLE IF EXISTS \"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\" DROP BRANCH IF EXISTS 'w]-'", "w]-", "?^Ch");
      CreateType createType0 = new CreateType(qualifiedName0, immutableList1, immutableList1);
      List<String> list1 = createType0.getParameterTypes();
      Optional<List<String>> optional2 = Optional.ofNullable(list1);
      optional2.toString();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier1);
      Grant grant0 = new Grant(nodeLocation1, optional2, true, qualifiedName0, principalSpecification0, false);
      SqlFormatter.formatSql(identifier1, optional1);
      Random.setNextRandom(412);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull62()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      QualifiedName qualifiedName0 = QualifiedName.of(") outside buffer: ");
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      identifier0.getChildren();
      DropTag dropTag0 = new DropTag(nodeLocation0, qualifiedName0, ") outside buffer: ", false, false);
      dropTag0.equals(") outside buffer: ");
      dropTag0.getChildren();
      dropTag0.getUpdateInfo();
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      dropTag0.getUpdateInfo();
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      String string0 = SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlAndFormatSqlWithNonNull()  throws Throwable  {
      TableSubquery tableSubquery0 = new TableSubquery((Query) null);
      Optional<List<Expression>> optional0 = Optional.empty();
      QualifiedName qualifiedName0 = QualifiedName.of("~i");
      DropTag dropTag0 = new DropTag(qualifiedName0, "~i", false, false);
      dropTag0.toString();
      SqlFormatter.formatSql(dropTag0, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(tableSubquery0, optional0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull53()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(1, 1589);
      Optional<String> optional0 = Optional.of("0Ip");
      ShowCatalogs showCatalogs0 = new ShowCatalogs(optional0, optional0);
      Optional<String> optional1 = showCatalogs0.getLikePattern();
      ShowCatalogs showCatalogs1 = new ShowCatalogs(nodeLocation0, optional1, optional1);
      AstVisitor<LinkedList<Locale.FilteringMode>, Locale.FilteringMode> astVisitor0 = (AstVisitor<LinkedList<Locale.FilteringMode>, Locale.FilteringMode>) mock(AstVisitor.class, new ViolatedAssumptionAnswer());
      Locale.FilteringMode locale_FilteringMode0 = Locale.FilteringMode.AUTOSELECT_FILTERING;
      showCatalogs1.accept(astVisitor0, locale_FilteringMode0);
      optional0.isPresent();
      showCatalogs1.getUpdateInfo();
      showCatalogs1.getChildren();
      SqlFormatter.formatSql(showCatalogs1, (Optional<List<Expression>>) null);
      Random.setNextRandom(3);
      Random.setNextRandom(0);
      Random.setNextRandom(1589);
      Random.setNextRandom(3);
      SqlFormatter.formatSql(showCatalogs0, (Optional<List<Expression>>) null);
      Random.setNextRandom(1773);
      SqlFormatter.formatSql(showCatalogs1, (Optional<List<Expression>>) null);
      Random.setNextRandom(1);
      DecimalLiteral decimalLiteral0 = new DecimalLiteral("o-WJ:EbcwSxzcv X;");
      Identifier identifier0 = new Identifier(nodeLocation0, "o-WJ:EbcwSxzcv X;", true);
      decimalLiteral0.equals(identifier0);
      decimalLiteral0.getChildren();
      SqlFormatter.formatSql(decimalLiteral0, (Optional<List<Expression>>) null);
      Random.setNextRandom(3);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull63()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      NodeLocation nodeLocation0 = new NodeLocation(1271, 1673);
      Optional<String> optional1 = Optional.empty();
      ShowCatalogs showCatalogs0 = new ShowCatalogs(nodeLocation0, optional1, optional1);
      String string0 = SqlFormatter.formatSql(showCatalogs0, optional0);
      assertEquals("SHOW CATALOGS", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull54()  throws Throwable  {
      CurrentUser currentUser0 = new CurrentUser();
      CallArgument callArgument0 = new CallArgument("", currentUser0);
      String string0 = SqlFormatter.formatSql(callArgument0, (Optional<List<Expression>>) null);
      assertEquals(" => CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNullAndFormatSqlWithNonNull4()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      LambdaArgumentDeclaration lambdaArgumentDeclaration0 = new LambdaArgumentDeclaration((Identifier) null);
      CallArgument callArgument0 = new CallArgument(nodeLocation0, "ROLES", lambdaArgumentDeclaration0);
      Optional<List<Expression>> optional0 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(callArgument0, optional0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.Node.accept(com.facebook.presto.sql.tree.AstVisitor, Object)\" because \"node\" is null
         //
         verifyException("com.facebook.presto.sql.tree.AstVisitor", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull55()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      LinkedList<WhenClause> linkedList0 = new LinkedList<WhenClause>();
      Table table0 = new Table(qualifiedName0);
      String string0 = SqlFormatter.formatSql(table0, (Optional<List<Expression>>) null);
      assertEquals("\"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull56()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      QualifiedName qualifiedName0 = QualifiedName.of(") outside buffer: ");
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      identifier0.getChildren();
      DropTag dropTag0 = new DropTag(nodeLocation0, qualifiedName0, ") outside buffer: ", true, true);
      dropTag0.equals(") outside buffer: ");
      dropTag0.getChildren();
      dropTag0.getUpdateInfo();
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      dropTag0.getUpdateInfo();
      String string0 = SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      LinkedList<WhenClause> linkedList0 = new LinkedList<WhenClause>();
      Vector<WhenClause> vector0 = new Vector<WhenClause>(linkedList0);
      Optional<Expression> optional0 = Optional.ofNullable(identifier0);
      SearchedCaseExpression searchedCaseExpression0 = new SearchedCaseExpression(nodeLocation0, linkedList0, optional0);
      Optional<Expression> optional1 = searchedCaseExpression0.getDefaultValue();
      SearchedCaseExpression searchedCaseExpression1 = new SearchedCaseExpression(vector0, optional1);
      SqlFormatter.formatSql(searchedCaseExpression1, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(searchedCaseExpression0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(searchedCaseExpression1, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(searchedCaseExpression1, (Optional<List<Expression>>) null);
      Table table0 = new Table(qualifiedName0);
      RefreshMaterializedView refreshMaterializedView0 = new RefreshMaterializedView(table0, optional0);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(table0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(refreshMaterializedView0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull66()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-142), (-142));
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet1.toArray();
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      String[] stringArray0 = new String[7];
      stringArray0[0] = "z:4Zfg~Uzm";
      stringArray0[1] = "addDFAState ";
      stringArray0[2] = "z:4Zfg~Uzm";
      stringArray0[3] = "z:4Zfg~Uzm";
      stringArray0[4] = "z:4Zfg~Uzm";
      stringArray0[5] = "z:4Zfg~Uzm";
      stringArray0[6] = "z:4Zfg~Uzm";
      QualifiedName qualifiedName0 = QualifiedName.of("z:4Zfg~Uzm", stringArray0);
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      linkedHashSet1.addFirst(principalSpecification0);
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      optional0.ifPresent(consumer0);
      Set<Identifier> set0 = grantRoles0.getRoles();
      GrantRoles grantRoles1 = new GrantRoles(nodeLocation0, set0, linkedHashSet1, true, optional0);
      Identifier identifier1 = null;
      linkedHashSet0.add((Identifier) null);
      Optional<List<Expression>> optional1 = Optional.empty();
      SqlFormatter.formatSql(grantRoles1, optional1);
      Supplier<Optional<List<Expression>>> supplier0 = (Supplier<Optional<List<Expression>>>) mock(Supplier.class, new ViolatedAssumptionAnswer());
      doReturn((Object) null).when(supplier0).get();
      // Undeclared exception!
      try { 
        optional1.or(supplier0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("java.util.Objects", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull63()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      List<Identifier> list0 = new LinkedList<Identifier>();
      Optional<List<String>> optional1 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.UNSPECIFIED;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("Cu,zf");
      Grant grant0 = new Grant(nodeLocation0, optional1, true, qualifiedName0, principalSpecification0, false);
      String string0 = SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      assertEquals("GRANT ALL PRIVILEGES ON TABLE cu,zf TO \"Cu,zf\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull64()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier1, identifier1);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, "w]-", true, false);
      Optional<List<String>> optional1 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName1 = QualifiedName.of((Iterable<Identifier>) list0);
      Grant grant0 = new Grant(nodeLocation0, optional1, true, qualifiedName1, principalSpecification0, false);
      String string0 = SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(dropBranch0, (Optional<List<Expression>>) null);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull67()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      Identifier identifier2 = new Identifier("Cu,zf");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier2, identifier2);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, "w]-", true, false);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(list0);
      Optional<List<Expression>> optional1 = Optional.ofNullable(immutableList0);
      SqlFormatter.formatSql(identifier1, optional1);
      String string0 = SqlFormatter.formatSql(dropBranch0, optional1);
      NodeLocation nodeLocation1 = new NodeLocation(3493, 412);
      ImmutableList<String> immutableList1 = ImmutableList.of("7m}J2", "Cu,zf", "ALTER TABLE IF EXISTS \"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\" DROP BRANCH 'w]-'", "w]-", "?^Ch");
      CreateType createType0 = new CreateType(qualifiedName0, immutableList1, immutableList1);
      List<String> list1 = createType0.getParameterTypes();
      Optional<List<String>> optional2 = Optional.ofNullable(list1);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier1);
      Grant grant0 = new Grant(nodeLocation1, optional2, false, qualifiedName0, principalSpecification0, false);
      SqlFormatter.formatSql(grant0, optional1);
      String string1 = SqlFormatter.formatSql(identifier2, optional1);
      assertFalse(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull65()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier1, identifier1);
      Optional<List<String>> optional1 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("Cu,zf");
      Grant grant0 = new Grant(nodeLocation0, optional1, true, qualifiedName0, principalSpecification0, false);
      String string0 = SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      assertEquals("GRANT ALL PRIVILEGES ON TABLE cu,zf TO ROLE \"Cu,zf\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull66()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional.empty();
      Optional<List<String>> optional0 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.USER;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of("ISH=,6(pzma:iP");
      Grant grant0 = new Grant(nodeLocation0, optional0, false, qualifiedName0, principalSpecification0, false);
      String string0 = SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      assertEquals("GRANT ALL PRIVILEGES ON ish=,6(pzma:ip TO USER \"SHOW CATALOGS\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull67()  throws Throwable  {
      Identifier identifier0 = new Identifier("Cu,zf", true);
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<String>> optional0 = Optional.ofNullable(null);
      PrincipalSpecification.Type principalSpecification_Type0 = PrincipalSpecification.Type.ROLE;
      PrincipalSpecification principalSpecification0 = new PrincipalSpecification(principalSpecification_Type0, identifier0);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      Grant grant0 = new Grant(optional0, false, qualifiedName0, principalSpecification0, true);
      SqlFormatter.formatSql(grant0, (Optional<List<Expression>>) null);
      Random.setNextRandom(3);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull57()  throws Throwable  {
      ExternalBodyReference externalBodyReference0 = new ExternalBodyReference();
      String string0 = SqlFormatter.formatSql(externalBodyReference0, (Optional<List<Expression>>) null);
      assertEquals("EXTERNAL", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull64()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 1697);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "L?TY-Cyj|]zi;4_";
      QualifiedName qualifiedName0 = QualifiedName.of("L?TY-Cyj|]zi;4_", stringArray0);
      Identifier identifier0 = new Identifier("/Fv%_Y$MkkRUn:");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      Deallocate deallocate0 = new Deallocate(identifier0);
      SqlFormatter.formatSql(deallocate0, optional0);
      Random.setNextRandom(1697);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull58()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      Identifier identifier0 = new Identifier(nodeLocation0, "{D\"c5n16S!Ial%[vQ", true);
      Deallocate deallocate0 = new Deallocate(identifier0);
      String string0 = SqlFormatter.formatSql(deallocate0, (Optional<List<Expression>>) null);
      assertEquals("DEALLOCATE PREPARE \"{D\"\"c5n16S!Ial%[vQ\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull68()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-142), (-142));
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet1.toArray();
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      optional0.ifPresent(consumer0);
      GrantRoles grantRoles1 = new GrantRoles(nodeLocation0, linkedHashSet0, linkedHashSet1, true, optional0);
      Optional<List<Expression>> optional1 = Optional.empty();
      String string0 = SqlFormatter.formatSql(grantRoles1, optional1);
      assertEquals("GRANT  TO  WITH ADMIN OPTION GRANTED BY CURRENT_ROLE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull68()  throws Throwable  {
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_ROLE;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, linkedHashSet0, false, optional0);
      String string0 = SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
      assertEquals("GRANT  TO  GRANTED BY CURRENT_ROLE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull69()  throws Throwable  {
      LinkedHashSet<PrincipalSpecification> linkedHashSet0 = new LinkedHashSet<PrincipalSpecification>();
      GrantorSpecification.Type grantorSpecification_Type0 = GrantorSpecification.Type.CURRENT_USER;
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn(grantorSpecification_Type0).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet1 = new LinkedHashSet<Identifier>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet1, linkedHashSet0, false, optional0);
      String string0 = SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
      assertEquals("GRANT  TO  GRANTED BY CURRENT_USER", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlWithNonNull3()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      ExplainType.Type explainType_Type0 = ExplainType.Type.DISTRIBUTED;
      ExplainType explainType0 = new ExplainType(explainType_Type0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(explainType0, optional0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // not yet implemented: ExplainType{type=DISTRIBUTED}
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsUnsupportedOperationExceptionAndFormatSqlWithNonNull4()  throws Throwable  {
      int int0 = 2;
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      Identifier identifier0 = new Identifier(nodeLocation0, "", true);
      Property property0 = new Property(identifier0, identifier0);
      AstVisitor<MockThrowable, LinkedList<Object>> astVisitor0 = (AstVisitor<MockThrowable, LinkedList<Object>>) mock(AstVisitor.class, new ViolatedAssumptionAnswer());
      identifier0.getCanonicalValue();
      LinkedList<Object> linkedList0 = null;
      identifier0.accept(astVisitor0, null);
      Optional<List<Expression>> optional0 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(property0, optional0);
        fail("Expecting exception: UnsupportedOperationException");
      
      } catch(UnsupportedOperationException e) {
         //
         // not yet implemented: Property{name=\"\", value=\"\"}
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull70()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("&(fUG8^-o bL1gB");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      NodeLocation nodeLocation0 = new NodeLocation(18, 18);
      DropBranch dropBranch0 = new DropBranch(qualifiedName0, "&(fUG8^-o bL1gB", true, true);
      String string0 = SqlFormatter.formatSql(dropBranch0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE IF EXISTS \"&(fUG8^-o bL1gB\" DROP BRANCH IF EXISTS '&(fUG8^-o bL1gB'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull71()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("&(fUG8^-o bL1gB");
      ShowCreate.Type showCreate_Type0 = ShowCreate.Type.MATERIALIZED_VIEW;
      ShowCreate showCreate0 = new ShowCreate(showCreate_Type0, qualifiedName0);
      NodeLocation nodeLocation0 = new NodeLocation(18, 18);
      DropBranch dropBranch0 = new DropBranch(qualifiedName0, "&(fUG8^-o bL1gB", false, false);
      String string0 = SqlFormatter.formatSql(dropBranch0, (Optional<List<Expression>>) null);
      assertEquals("ALTER TABLE \"&(fUG8^-o bL1gB\" DROP BRANCH '&(fUG8^-o bL1gB'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull69()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(412, 412);
      Identifier identifier0 = new Identifier("Cu,zf", true);
      Optional<NodeLocation> optional0 = Optional.of(nodeLocation0);
      Identifier identifier1 = new Identifier(optional0, "Cu,zf");
      Identifier identifier2 = new Identifier("Cu,zf");
      List<Identifier> list0 = List.of(identifier0, identifier0, identifier0, identifier1, identifier1, identifier0, identifier1, identifier1, identifier2, identifier2);
      QualifiedName qualifiedName0 = QualifiedName.of((Iterable<Identifier>) list0);
      DropBranch dropBranch0 = new DropBranch(nodeLocation0, qualifiedName0, "w]-", true, false);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(list0);
      Optional<List<Expression>> optional1 = Optional.ofNullable(immutableList0);
      String string0 = SqlFormatter.formatSql(dropBranch0, optional1);
      assertEquals("ALTER TABLE IF EXISTS \"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\".\"Cu,zf\" DROP BRANCH 'w]-'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull65()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-282), (-282));
      Isolation.Level isolation_Level0 = Isolation.Level.SERIALIZABLE;
      Isolation isolation0 = new Isolation(isolation_Level0);
      ImmutableList<Isolation> immutableList0 = ImmutableList.of(isolation0, isolation0, isolation0, isolation0, isolation0);
      ImmutableList<TransactionMode> immutableList1 = ImmutableList.copyOf(immutableList0);
      StartTransaction startTransaction0 = new StartTransaction(nodeLocation0, immutableList1);
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(startTransaction0, optional0);
      assertEquals("START TRANSACTION ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SERIALIZABLE, ISOLATION LEVEL SERIALIZABLE", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull70()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      Isolation.Level isolation_Level0 = Isolation.Level.READ_UNCOMMITTED;
      Isolation isolation0 = new Isolation(isolation_Level0);
      String string0 = SqlFormatter.formatSql(isolation0, optional0);
      assertEquals("ISOLATION LEVEL READ UNCOMMITTED", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull59()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(3260, 3260);
      Isolation.Level isolation_Level0 = Isolation.Level.READ_COMMITTED;
      Isolation isolation0 = new Isolation(isolation_Level0);
      ImmutableList<TransactionMode> immutableList0 = ImmutableList.of(isolation0);
      StartTransaction startTransaction0 = new StartTransaction(nodeLocation0, immutableList0);
      String string0 = SqlFormatter.formatSql(startTransaction0, (Optional<List<Expression>>) null);
      assertEquals("START TRANSACTION ISOLATION LEVEL READ COMMITTED", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull72()  throws Throwable  {
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(null);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      String string0 = SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
      assertEquals("GRANT  TO  WITH ADMIN OPTION", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNonNull7()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-142), (-142));
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      LinkedHashSet<PrincipalSpecification> linkedHashSet1 = new LinkedHashSet<PrincipalSpecification>();
      linkedHashSet1.toArray();
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, linkedHashSet1, true, optional0);
      Consumer<Object> consumer0 = (Consumer<Object>) mock(Consumer.class, new ViolatedAssumptionAnswer());
      optional0.ifPresent(consumer0);
      Set<Identifier> set0 = grantRoles0.getRoles();
      GrantRoles grantRoles1 = new GrantRoles(nodeLocation0, set0, linkedHashSet1, true, optional0);
      linkedHashSet0.add((Identifier) null);
      Optional<List<Expression>> optional1 = Optional.empty();
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(grantRoles1, optional1);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlThrowsNullPointerExceptionAndFormatSqlWithNull7()  throws Throwable  {
      GrantorSpecification grantorSpecification0 = mock(GrantorSpecification.class, new ViolatedAssumptionAnswer());
      doReturn((GrantorSpecification.Type) null).when(grantorSpecification0).getType();
      Optional<GrantorSpecification> optional0 = Optional.ofNullable(grantorSpecification0);
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      HashSet<PrincipalSpecification> hashSet0 = new HashSet<PrincipalSpecification>();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, hashSet0, false, optional0);
      // Undeclared exception!
      try { 
        SqlFormatter.formatSql(grantRoles0, (Optional<List<Expression>>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"com.facebook.presto.sql.tree.GrantorSpecification$Type.ordinal()\" because \"type\" is null
         //
         verifyException("com.facebook.presto.sql.SqlFormatter$Formatter", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull71()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      System.setCurrentTimeMillis(0L);
      QualifiedName qualifiedName0 = QualifiedName.of(" y_YQ!");
      DropTag dropTag0 = new DropTag(qualifiedName0, "O~=GYJ~lp", true, false);
      String string0 = SqlFormatter.formatSql(dropTag0, optional0);
      assertEquals("ALTER TABLE IF EXISTS \" y_YQ!\" DROP TAG 'O~=GYJ~lp'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull60()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(0, 0);
      QualifiedName qualifiedName0 = QualifiedName.of(") outside buffer: ");
      Identifier identifier0 = qualifiedName0.getOriginalSuffix();
      identifier0.getChildren();
      DropTag dropTag0 = new DropTag(nodeLocation0, qualifiedName0, ") outside buffer: ", true, true);
      dropTag0.equals(") outside buffer: ");
      dropTag0.getChildren();
      dropTag0.getUpdateInfo();
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      dropTag0.getUpdateInfo();
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      LinkedList<WhenClause> linkedList0 = new LinkedList<WhenClause>();
      Vector<WhenClause> vector0 = new Vector<WhenClause>(linkedList0);
      Optional<Expression> optional0 = Optional.ofNullable(identifier0);
      SearchedCaseExpression searchedCaseExpression0 = new SearchedCaseExpression(nodeLocation0, linkedList0, optional0);
      Optional<Expression> optional1 = searchedCaseExpression0.getDefaultValue();
      SearchedCaseExpression searchedCaseExpression1 = new SearchedCaseExpression(vector0, optional1);
      SqlFormatter.formatSql(searchedCaseExpression1, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(searchedCaseExpression0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      String string0 = SqlFormatter.formatSql(searchedCaseExpression1, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      SqlFormatter.formatSql(identifier0, (Optional<List<Expression>>) null);
      Table table0 = new Table(qualifiedName0);
      RefreshMaterializedView refreshMaterializedView0 = new RefreshMaterializedView(table0, optional1);
      SqlFormatter.formatSql(refreshMaterializedView0, (Optional<List<Expression>>) null);
      String string1 = SqlFormatter.formatSql(searchedCaseExpression0, (Optional<List<Expression>>) null);
      assertTrue(string1.equals((Object)string0));
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNull73()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("VFy(s");
      NodeLocation nodeLocation0 = new NodeLocation(9, 1033);
      DropTag dropTag0 = new DropTag(nodeLocation0, qualifiedName0, "VFy(s", true, true);
      SqlFormatter.formatSql(dropTag0, (Optional<List<Expression>>) null);
      System.setCurrentTimeMillis(0L);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull61()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("Ax)ifuY4>q|");
      RenameView renameView0 = new RenameView(qualifiedName0, qualifiedName0, true);
      ExplainFormat.Type explainFormat_Type0 = ExplainFormat.Type.JSON;
      ExplainFormat explainFormat0 = new ExplainFormat(explainFormat_Type0);
      NodeLocation nodeLocation0 = new NodeLocation((-3220), (-3220));
      ImmutableList<ExplainOption> immutableList0 = ImmutableList.of(explainFormat0, explainFormat0, explainFormat0);
      Explain explain0 = new Explain(nodeLocation0, true, false, renameView0, immutableList0);
      Table table0 = new Table(nodeLocation0, qualifiedName0);
      Optional<NodeLocation> optional0 = Optional.ofNullable(nodeLocation0);
      DecimalLiteral decimalLiteral0 = new DecimalLiteral(optional0, "(pCrM");
      IfExpression ifExpression0 = new IfExpression(nodeLocation0, decimalLiteral0, decimalLiteral0, decimalLiteral0);
      Optional<Expression> optional1 = ifExpression0.getFalseValue();
      RefreshMaterializedView refreshMaterializedView0 = new RefreshMaterializedView(table0, optional1);
      String string0 = SqlFormatter.formatSql(refreshMaterializedView0, (Optional<List<Expression>>) null);
      assertEquals("REFRESH MATERIALIZED VIEW \"Ax)ifuY4>q|\" WHERE DECIMAL '(pCrM'", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull72()  throws Throwable  {
      Optional<List<Expression>> optional0 = Optional.empty();
      LinkedHashSet<Identifier> linkedHashSet0 = new LinkedHashSet<Identifier>();
      HashSet<PrincipalSpecification> hashSet0 = new HashSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional1 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(linkedHashSet0, hashSet0, false, optional1);
      String string0 = SqlFormatter.formatSql(grantRoles0, optional0);
      assertEquals("GRANT  TO ", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull66()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), (-2989));
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, false, optional0);
      Optional<GrantorSpecification> optional1 = grantRoles0.getGrantor();
      CreateRole createRole0 = new CreateRole(nodeLocation0, identifier0, optional1);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      createRole0.getUpdateInfo();
      Optional<List<Expression>> optional2 = Optional.of(immutableList0);
      NullLiteral nullLiteral0 = new NullLiteral();
      String string0 = SqlFormatter.formatSql(createRole0, optional2);
      assertEquals("CREATE ROLE \"SHOW CATALOGS\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNonNull67()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation((-2989), 4783);
      Identifier identifier0 = new Identifier("SHOW CATALOGS");
      HashSet<Identifier> hashSet0 = new HashSet<Identifier>();
      TreeSet<PrincipalSpecification> treeSet0 = new TreeSet<PrincipalSpecification>();
      identifier0.getCanonicalValue();
      Optional<GrantorSpecification> optional0 = Optional.empty();
      GrantRoles grantRoles0 = new GrantRoles(nodeLocation0, hashSet0, treeSet0, false, optional0);
      Optional<GrantorSpecification> optional1 = grantRoles0.getGrantor();
      CreateRole createRole0 = new CreateRole(nodeLocation0, identifier0, optional1);
      ImmutableList<Expression> immutableList0 = ImmutableList.copyOf(hashSet0);
      List.of(identifier0, identifier0, identifier0, identifier0, identifier0);
      createRole0.getUpdateInfo();
      grantRoles0.toString();
      grantRoles0.getUpdateInfo();
      Optional<List<Expression>> optional2 = Optional.of(immutableList0);
      SqlFormatter.formatSql(createRole0, optional2);
      SqlFormatter.formatSql(identifier0, optional2);
      SqlFormatter.formatSql(grantRoles0, optional2);
      SqlFormatter.formatSql(createRole0, optional2);
      SqlFormatter.formatSql(createRole0, optional2);
      SqlFormatter.formatSql(createRole0, optional2);
      SqlFormatter.formatSql(createRole0, optional2);
      Funnel<Object> funnel0 = (Funnel<Object>) mock(Funnel.class, new ViolatedAssumptionAnswer());
      // Undeclared exception!
      try { 
        BloomFilter.create(funnel0, 0L, (-2989));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // False positive probability (java.lang.Double@0000000024) must be > 0.0
         //
         verifyException("com.google.common.base.Preconditions", e);
      }
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull73()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "ROLES";
      QualifiedName qualifiedName0 = QualifiedName.of("ROLES", stringArray0);
      Identifier identifier0 = new Identifier("ROLES");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, false, true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(dropColumn0, optional0);
      assertEquals("ALTER TABLE ROLES.ROLES DROP COLUMN IF EXISTS ROLES", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull74()  throws Throwable  {
      Commit commit0 = new Commit();
      Optional<List<Expression>> optional0 = Optional.empty();
      String string0 = SqlFormatter.formatSql(commit0, optional0);
      assertEquals("COMMIT", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNullAndFormatSqlWithNull62()  throws Throwable  {
      QualifiedName qualifiedName0 = QualifiedName.of("");
      ShowColumns showColumns0 = new ShowColumns(qualifiedName0);
      String string0 = SqlFormatter.formatSql(showColumns0, (Optional<List<Expression>>) null);
      assertEquals("SHOW COLUMNS FROM \"\"", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSqlWithNonNull75()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 2);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "ROLES";
      QualifiedName qualifiedName0 = QualifiedName.of("ROLES", stringArray0);
      Identifier identifier0 = new Identifier("ROLES");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(dropColumn0, optional0);
      assertEquals("ALTER TABLE IF EXISTS ROLES.ROLES DROP COLUMN IF EXISTS ROLES", string0);
  }

  @Test(timeout = 4000)
  public void testFormatSqlAndFormatSql()  throws Throwable  {
      NodeLocation nodeLocation0 = new NodeLocation(2, 1697);
      String[] stringArray0 = new String[1];
      stringArray0[0] = "L?TY-Cyj|]zi;4_";
      QualifiedName qualifiedName0 = QualifiedName.of("L?TY-Cyj|]zi;4_", stringArray0);
      Identifier identifier0 = new Identifier("/Fv%_Y$MkkRUn:");
      DropColumn dropColumn0 = new DropColumn(nodeLocation0, qualifiedName0, identifier0, true, true);
      ImmutableList<Expression> immutableList0 = ImmutableList.of(identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0, identifier0);
      Optional<List<Expression>> optional0 = Optional.of(immutableList0);
      String string0 = SqlFormatter.formatSql(dropColumn0, optional0);
      assertEquals("ALTER TABLE IF EXISTS \"L?TY-Cyj|]zi;4_\".\"L?TY-Cyj|]zi;4_\" DROP COLUMN IF EXISTS \"/Fv%_Y$MkkRUn:\"", string0);
  }
}
