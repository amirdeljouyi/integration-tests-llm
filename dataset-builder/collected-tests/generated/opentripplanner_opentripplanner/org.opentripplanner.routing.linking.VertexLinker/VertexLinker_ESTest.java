/*
 * This file was automatically generated by UTestGen and EvoSuite
 * Tue Jan 13 22:31:02 GMT 2026
 */

package org.opentripplanner.routing.linking;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.function.BiFunction;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.junit.runner.RunWith;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.LinearRing;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.impl.PackedCoordinateSequenceFactory;
import org.opentripplanner.routing.graph.Graph;
import org.opentripplanner.routing.linking.DisposableEdgeCollection;
import org.opentripplanner.routing.linking.VertexLinker;
import org.opentripplanner.routing.linking.VisibilityMode;
import org.opentripplanner.street.model.StreetTraversalPermission;
import org.opentripplanner.street.model.edge.AreaGroup;
import org.opentripplanner.street.model.edge.Edge;
import org.opentripplanner.street.model.edge.FreeEdge;
import org.opentripplanner.street.model.edge.LinkingDirection;
import org.opentripplanner.street.model.edge.StreetEdge;
import org.opentripplanner.street.model.edge.TemporaryPartialStreetEdge;
import org.opentripplanner.street.model.vertex.BarrierVertex;
import org.opentripplanner.street.model.vertex.IntersectionVertex;
import org.opentripplanner.street.model.vertex.StreetVertex;
import org.opentripplanner.street.model.vertex.SubsidiaryVertex;
import org.opentripplanner.street.model.vertex.Vertex;
import org.opentripplanner.street.search.TraverseMode;
import org.opentripplanner.street.search.TraverseModeSet;
import org.opentripplanner.transit.model.basic.Accessibility;

public class VertexLinker_ESTest extends VertexLinker_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void testLinkToSpecificStreetEdgesPermanentlyWithLinkingDirectionWhereAllowOutgoingIsTrue()  throws Throwable  {
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, (-2));
      Accessibility accessibility0 = Accessibility.NOT_POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, (-2), 0L, accessibility0);
      TraverseModeSet traverseModeSet0 = TraverseModeSet.allModes();
      LinkingDirection linkingDirection0 = LinkingDirection.BIDIRECTIONAL;
      TemporaryPartialStreetEdge temporaryPartialStreetEdge0 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      doReturn((LineString) null).when(temporaryPartialStreetEdge0).getGeometry();
      TemporaryPartialStreetEdge temporaryPartialStreetEdge1 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      List<TemporaryPartialStreetEdge> list0 = List.of(temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge1);
      HashSet<StreetEdge> hashSet0 = new HashSet<StreetEdge>(list0);
      // Undeclared exception!
      try { 
        vertexLinker0.linkToSpecificStreetEdgesPermanently(barrierVertex0, traverseModeSet0, linkingDirection0, hashSet0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot invoke \"org.locationtech.jts.geom.LineString.getNumPoints()\" because \"geometry\" is null
         //
         verifyException("org.opentripplanner.routing.linking.VertexLinker", e);
      }
  }

  @Test(timeout = 4000)
  public void testLinkVertexForRealTime()  throws Throwable  {
      Graph graph0 = new Graph();
      graph0.requestIndex();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, 1);
      Accessibility accessibility0 = Accessibility.NOT_POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex(1243.75554, (-2635.888530840074), 0L, accessibility0);
      TraverseMode[] traverseModeArray0 = new TraverseMode[5];
      TraverseMode traverseMode0 = TraverseMode.FLEX;
      traverseModeArray0[0] = traverseMode0;
      traverseModeArray0[1] = traverseMode0;
      traverseModeArray0[2] = traverseModeArray0[0];
      traverseModeArray0[3] = traverseModeArray0[1];
      traverseModeArray0[4] = traverseModeArray0[1];
      TraverseModeSet traverseModeSet0 = new TraverseModeSet(traverseModeArray0);
      LinkingDirection linkingDirection0 = LinkingDirection.INCOMING;
      BiFunction<Vertex, StreetVertex, List<Edge>> biFunction0 = (BiFunction<Vertex, StreetVertex, List<Edge>>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      DisposableEdgeCollection disposableEdgeCollection0 = vertexLinker0.linkVertexForRealTime(barrierVertex0, traverseModeSet0, linkingDirection0, biFunction0);
      assertTrue(disposableEdgeCollection0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testLinkToSpecificStreetEdgesPermanently()  throws Throwable  {
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, (-2));
      Accessibility accessibility0 = Accessibility.POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, (-2), 0L, accessibility0);
      TraverseModeSet traverseModeSet0 = TraverseModeSet.allModes();
      PackedCoordinateSequenceFactory packedCoordinateSequenceFactory0 = new PackedCoordinateSequenceFactory();
      GeometryFactory geometryFactory0 = new GeometryFactory(packedCoordinateSequenceFactory0);
      LinearRing linearRing0 = geometryFactory0.createLinearRing();
      TemporaryPartialStreetEdge temporaryPartialStreetEdge0 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      doReturn(false, false, false, false).when(temporaryPartialStreetEdge0).canTraverse(any(org.opentripplanner.street.search.TraverseModeSet.class));
      doReturn(linearRing0).when(temporaryPartialStreetEdge0).getGeometry();
      List<TemporaryPartialStreetEdge> list0 = List.of(temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0);
      HashSet<StreetEdge> hashSet0 = new HashSet<StreetEdge>(list0);
      LinkingDirection linkingDirection0 = LinkingDirection.BIDIRECTIONAL;
      Set<StreetVertex> set0 = vertexLinker0.linkToSpecificStreetEdgesPermanently(barrierVertex0, traverseModeSet0, linkingDirection0, hashSet0);
      assertEquals(0, set0.size());
  }

  @Test(timeout = 4000)
  public void testGetNoThruModesReturningSetWhereIsEmptyIsFalse()  throws Throwable  {
      TemporaryPartialStreetEdge temporaryPartialStreetEdge0 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      doReturn(true, true, true).when(temporaryPartialStreetEdge0).isNoThruTraffic(any(org.opentripplanner.street.search.TraverseMode.class));
      LinkedBlockingQueue<Edge> linkedBlockingQueue0 = new LinkedBlockingQueue<Edge>();
      linkedBlockingQueue0.add(temporaryPartialStreetEdge0);
      Set<TraverseMode> set0 = VertexLinker.getNoThruModes(linkedBlockingQueue0);
      assertFalse(set0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testGetNoThruModesReturningSetWhereIsEmptyIsTrueAndSetWhereSizeIsZero()  throws Throwable  {
      TemporaryPartialStreetEdge temporaryPartialStreetEdge0 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      doReturn(false, false, false).when(temporaryPartialStreetEdge0).isNoThruTraffic(any(org.opentripplanner.street.search.TraverseMode.class));
      LinkedBlockingQueue<Edge> linkedBlockingQueue0 = new LinkedBlockingQueue<Edge>();
      linkedBlockingQueue0.add(temporaryPartialStreetEdge0);
      Set<TraverseMode> set0 = VertexLinker.getNoThruModes(linkedBlockingQueue0);
      assertEquals(0, set0.size());
  }

  @Test(timeout = 4000)
  public void testGetNoThruModesReturningSetWhereSizeIsPositive()  throws Throwable  {
      Graph graph0 = new Graph();
      Accessibility accessibility0 = Accessibility.POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, 0L, 0L, accessibility0);
      FreeEdge freeEdge0 = FreeEdge.createFreeEdge(barrierVertex0, barrierVertex0);
      LinkedBlockingQueue<Edge> linkedBlockingQueue0 = new LinkedBlockingQueue<Edge>();
      linkedBlockingQueue0.add(freeEdge0);
      Set<TraverseMode> set0 = VertexLinker.getNoThruModes(linkedBlockingQueue0);
      assertEquals(3, set0.size());
  }

  @Test(timeout = 4000)
  public void testLinkVertexForRequest()  throws Throwable  {
      Graph graph0 = new Graph();
      graph0.requestIndex();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, 1);
      Accessibility accessibility0 = Accessibility.POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, 1.0E8, 314L, accessibility0);
      Stack<TraverseMode> stack0 = new Stack<TraverseMode>();
      TraverseModeSet traverseModeSet0 = new TraverseModeSet(stack0);
      LinkingDirection linkingDirection0 = LinkingDirection.OUTGOING;
      BiFunction<Vertex, StreetVertex, List<Edge>> biFunction0 = (BiFunction<Vertex, StreetVertex, List<Edge>>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      DisposableEdgeCollection disposableEdgeCollection0 = vertexLinker0.linkVertexForRequest(barrierVertex0, traverseModeSet0, linkingDirection0, biFunction0);
      assertTrue(disposableEdgeCollection0.isEmpty());
  }

  @Test(timeout = 4000)
  public void testLinkVertexPermanently()  throws Throwable  {
      Graph graph0 = new Graph();
      graph0.requestIndex();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, (-2));
      Accessibility accessibility0 = Accessibility.NOT_POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, (-2), 0L, accessibility0);
      TraverseModeSet traverseModeSet0 = TraverseModeSet.allModes();
      LinkingDirection linkingDirection0 = LinkingDirection.BIDIRECTIONAL;
      vertexLinker0.linkVertexPermanently(barrierVertex0, traverseModeSet0, linkingDirection0, (BiFunction<Vertex, StreetVertex, List<Edge>>) null);
      assertEquals(StreetTraversalPermission.ALL, barrierVertex0.getBarrierPermissions());
  }

  @Test(timeout = 4000)
  public void testLinkToSpecificStreetEdgesPermanentlyWithLinkingDirectionWhereAllowOutgoingIsFalse()  throws Throwable  {
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, (-2));
      Accessibility accessibility0 = Accessibility.POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, (-2), 0L, accessibility0);
      TraverseModeSet traverseModeSet0 = TraverseModeSet.allModes();
      PackedCoordinateSequenceFactory packedCoordinateSequenceFactory0 = new PackedCoordinateSequenceFactory();
      GeometryFactory geometryFactory0 = new GeometryFactory(packedCoordinateSequenceFactory0);
      LinearRing linearRing0 = geometryFactory0.createLinearRing();
      TemporaryPartialStreetEdge temporaryPartialStreetEdge0 = mock(TemporaryPartialStreetEdge.class, new ViolatedAssumptionAnswer());
      doReturn(true, false, true, true).when(temporaryPartialStreetEdge0).canTraverse(any(org.opentripplanner.street.search.TraverseModeSet.class));
      doReturn(linearRing0, linearRing0).when(temporaryPartialStreetEdge0).getGeometry();
      List<TemporaryPartialStreetEdge> list0 = List.of(temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0, temporaryPartialStreetEdge0);
      HashSet<StreetEdge> hashSet0 = new HashSet<StreetEdge>(list0);
      LinkingDirection linkingDirection0 = LinkingDirection.INCOMING;
      // Undeclared exception!
      try { 
        vertexLinker0.linkToSpecificStreetEdgesPermanently(barrierVertex0, traverseModeSet0, linkingDirection0, hashSet0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // Cannot read field \"componentIndex\" because \"loc\" is null
         //
         verifyException("org.locationtech.jts.linearref.LinearLocation", e);
      }
  }

  @Test(timeout = 4000)
  public void testAddPermanentAreaVertex()  throws Throwable  {
      AreaGroup areaGroup0 = new AreaGroup((Polygon) null);
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.TRAVERSE_AREA_EDGES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, 0);
      boolean boolean0 = vertexLinker0.addPermanentAreaVertex((IntersectionVertex) null, areaGroup0);
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void testLinkVertexForRealTimeThrowsIllegalStateException()  throws Throwable  {
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, 1053);
      Accessibility accessibility0 = Accessibility.NOT_POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex(0.0, 0.0, 1L, accessibility0);
      SubsidiaryVertex subsidiaryVertex0 = new SubsidiaryVertex(barrierVertex0);
      TraverseMode[] traverseModeArray0 = new TraverseMode[4];
      TraverseMode traverseMode0 = TraverseMode.FLEX;
      traverseModeArray0[0] = traverseMode0;
      traverseModeArray0[1] = traverseMode0;
      traverseModeArray0[2] = traverseMode0;
      traverseModeArray0[3] = traverseModeArray0[0];
      TraverseModeSet traverseModeSet0 = new TraverseModeSet(traverseModeArray0);
      LinkingDirection linkingDirection0 = LinkingDirection.BIDIRECTIONAL;
      // Undeclared exception!
      try { 
        vertexLinker0.linkVertexForRealTime(subsidiaryVertex0, traverseModeSet0, linkingDirection0, (BiFunction<Vertex, StreetVertex, List<Edge>>) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Graph must be indexed before querying.
         //
         verifyException("org.opentripplanner.routing.graph.Graph", e);
      }
  }

  @Test(timeout = 4000)
  public void testLinkVertexPermanentlyThrowsIllegalStateException()  throws Throwable  {
      Graph graph0 = new Graph();
      VisibilityMode visibilityMode0 = VisibilityMode.COMPUTE_AREA_VISIBILITY_LINES;
      VertexLinker vertexLinker0 = new VertexLinker(graph0, visibilityMode0, (-2));
      Accessibility accessibility0 = Accessibility.NOT_POSSIBLE;
      BarrierVertex barrierVertex0 = new BarrierVertex((double) graph0.ellipsoidToGeoidDifference, (-2), 0L, accessibility0);
      TraverseModeSet traverseModeSet0 = TraverseModeSet.allModes();
      LinkingDirection linkingDirection0 = LinkingDirection.BIDIRECTIONAL;
      // Undeclared exception!
      try { 
        vertexLinker0.linkVertexPermanently(barrierVertex0, traverseModeSet0, linkingDirection0, (BiFunction<Vertex, StreetVertex, List<Edge>>) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Graph must be indexed before querying.
         //
         verifyException("org.opentripplanner.routing.graph.Graph", e);
      }
  }
}
